/**
 * Zero-allocation XML field extractor for Windows Event XML.
 *
 * Replaces fast-xml-parser (which builds a full DOM tree) with direct
 * indexOf + substring scanning. The XML structure is predictable since
 * it's generated by our own BinXml serializer.
 *
 * Uses a single forward pass through the <System> section, advancing
 * a cursor position so each field search starts where the previous ended.
 */

const EMPTY_RESULT = {
	eventId: '',
	level: 0,
	provider: '',
	computer: '',
	channel: '',
	task: '',
	opcode: '',
	keywords: '',
	version: '',
	processId: '',
	threadId: '',
	securityUserId: '',
	activityId: '',
	relatedActivityId: '',
	eventData: ''
} as const

/** Extract text between <tag ...>text</tag>. Returns [value, endPos]. */
function tagTextFrom(xml: string, tag: string, from: number): [string, number] {
	const needle = `<${tag}`
	const nLen = needle.length
	let open = from
	while (true) {
		open = xml.indexOf(needle, open)
		if (open === -1) return ['', from]
		const c = xml.charCodeAt(open + nLen)
		if (c === 62 || c === 32 || c === 47 || c === 9 || c === 10 || c === 13)
			break // > space / \t \n \r
		open += nLen
	}
	const gt = xml.indexOf('>', open + nLen)
	if (gt === -1) return ['', from]
	if (xml.charCodeAt(gt - 1) === 47) return ['', gt + 1] // self-closing />
	const closeTag = `</${tag}>`
	const close = xml.indexOf(closeTag, gt + 1)
	if (close === -1) return ['', gt + 1]
	return [xml.substring(gt + 1, close), close + closeTag.length]
}

/** Extract attribute value from <tag attr="value" ...>. Returns [value, endPosAfterGt]. */
function attrValFrom(
	xml: string,
	tag: string,
	attr: string,
	from: number
): [string, number] {
	const needle = `<${tag}`
	const nLen = needle.length
	let open = from
	while (true) {
		open = xml.indexOf(needle, open)
		if (open === -1) return ['', from]
		const c = xml.charCodeAt(open + nLen)
		if (c === 62 || c === 32 || c === 47 || c === 9 || c === 10 || c === 13)
			break
		open += nLen
	}
	const gt = xml.indexOf('>', open)
	if (gt === -1) return ['', from]
	const search = `${attr}="`
	const aStart = xml.indexOf(search, open + nLen)
	if (aStart === -1 || aStart >= gt) return ['', gt + 1]
	const vStart = aStart + search.length
	const vEnd = xml.indexOf('"', vStart)
	if (vEnd === -1 || vEnd > gt) return ['', gt + 1]
	return [xml.substring(vStart, vEnd), gt + 1]
}

/** Extract an attribute value from within a known tag region [start, gtPos). */
function attrInRange(
	xml: string,
	attr: string,
	start: number,
	end: number
): string {
	const search = `${attr}="`
	const aStart = xml.indexOf(search, start)
	if (aStart === -1 || aStart >= end) return ''
	const vStart = aStart + search.length
	const vEnd = xml.indexOf('"', vStart)
	return vEnd === -1 || vEnd > end ? '' : xml.substring(vStart, vEnd)
}

/** Find a tag and return [tagStart, gtPos]. Returns [-1, -1] if not found. */
function findTag(xml: string, tag: string, from: number): [number, number] {
	const needle = `<${tag}`
	const nLen = needle.length
	let open = from
	while (true) {
		open = xml.indexOf(needle, open)
		if (open === -1) return [-1, -1]
		const c = xml.charCodeAt(open + nLen)
		if (c === 62 || c === 32 || c === 47 || c === 9 || c === 10 || c === 13)
			break
		open += nLen
	}
	const gt = xml.indexOf('>', open)
	return gt === -1 ? [-1, -1] : [open, gt]
}

/** Decode basic XML entities. Fast-path returns immediately when no '&' present. */
function decodeEntities(s: string): string {
	if (s.indexOf('&') === -1) return s
	return s
		.replaceAll('&lt;', '<')
		.replaceAll('&gt;', '>')
		.replaceAll('&quot;', '"')
		.replaceAll('&apos;', "'")
		.replaceAll('&amp;', '&')
}

/** Extract <Data Name="x">value</Data> pairs from an EventData section */
function extractDataPairs(section: string): string {
	const pairs: string[] = []
	let pos = 0
	while (true) {
		const ds = section.indexOf('<Data', pos)
		if (ds === -1) break
		const gt = section.indexOf('>', ds + 5)
		if (gt === -1) break
		if (section.charCodeAt(gt - 1) === 47) {
			pos = gt + 1
			continue
		} // <Data ... />
		const ce = section.indexOf('</Data>', gt + 1)
		if (ce === -1) break
		const value = section.substring(gt + 1, ce)
		if (value) {
			const ni = section.indexOf('Name="', ds + 5)
			if (ni !== -1 && ni < gt) {
				const nvs = ni + 6
				const nve = section.indexOf('"', nvs)
				if (nve !== -1 && nve < gt) {
					pairs.push(`${section.substring(nvs, nve)}: ${decodeEntities(value)}`)
				} else {
					pairs.push(decodeEntities(value))
				}
			} else {
				pairs.push(decodeEntities(value))
			}
		}
		pos = ce + 7 // '</Data>'.length
	}
	return pairs.join('\n')
}

/** Extract leaf text elements (elements with no children) from a section */
function extractLeafPairs(section: string): string {
	const pairs: string[] = []
	let pos = 0
	while (pos < section.length) {
		const lt = section.indexOf('<', pos)
		if (lt === -1) break
		const nc = section.charCodeAt(lt + 1)
		if (nc === 47 || nc === 33 || nc === 63) {
			// closing tag, comment, PI
			const gt = section.indexOf('>', lt + 2)
			pos = gt === -1 ? section.length : gt + 1
			continue
		}
		// Extract tag name
		let ne = lt + 1
		while (ne < section.length) {
			const c = section.charCodeAt(ne)
			if (c === 32 || c === 62 || c === 47 || c === 9 || c === 10 || c === 13)
				break
			ne++
		}
		const tag = section.substring(lt + 1, ne)
		const gt = section.indexOf('>', lt)
		if (gt === -1) break
		if (section.charCodeAt(gt - 1) === 47) {
			pos = gt + 1
			continue
		} // self-closing
		const closeTag = `</${tag}>`
		const closePos = section.indexOf(closeTag, gt + 1)
		if (closePos === -1) {
			pos = gt + 1
			continue
		}
		const content = section.substring(gt + 1, closePos)
		// Only include leaf nodes (no child elements)
		if (content.indexOf('<') === -1) {
			const trimmed = content.trim()
			if (trimmed) pairs.push(`${tag}: ${decodeEntities(trimmed)}`)
		}
		pos = gt + 1
	}
	return pairs.join('\n')
}

export function parseEventXml(xmlString: string): {
	eventId: string
	level: number
	provider: string
	computer: string
	channel: string
	task: string
	opcode: string
	keywords: string
	version: string
	processId: string
	threadId: string
	securityUserId: string
	activityId: string
	relatedActivityId: string
	eventData: string
} {
	if (!xmlString) return {...EMPTY_RESULT}

	// Find <System> section once
	const sysOpen = xmlString.indexOf('<System>')
	if (sysOpen === -1) return {...EMPTY_RESULT}
	const sysClose = xmlString.indexOf('</System>', sysOpen)

	// Single forward pass through System fields in document order:
	// Provider, EventID, Version, Level, Task, Opcode, Keywords,
	// TimeCreated, EventRecordID, Correlation, Execution, Channel, Computer, Security
	let pos = sysOpen + 8 // after <System>
	let val: string

	// Provider (attribute on self-closing tag)
	;[val, pos] = attrValFrom(xmlString, 'Provider', 'Name', pos)
	const provider = decodeEntities(val)

	// EventID
	;[val, pos] = tagTextFrom(xmlString, 'EventID', pos)
	const eventId = decodeEntities(val)

	// Version
	;[val, pos] = tagTextFrom(xmlString, 'Version', pos)
	const version = val

	// Level
	;[val, pos] = tagTextFrom(xmlString, 'Level', pos)
	const level = val ? Number.parseInt(val, 10) || 0 : 0

	// Task
	;[val, pos] = tagTextFrom(xmlString, 'Task', pos)
	const task = val

	// Opcode
	;[val, pos] = tagTextFrom(xmlString, 'Opcode', pos)
	const opcode = val

	// Keywords
	;[val, pos] = tagTextFrom(xmlString, 'Keywords', pos)
	const keywords = val

	// Correlation (multi-attribute self-closing tag)
	let activityId = ''
	let relatedActivityId = ''
	const [corrStart, corrGt] = findTag(xmlString, 'Correlation', pos)
	if (corrStart !== -1) {
		activityId = attrInRange(xmlString, 'ActivityID', corrStart, corrGt)
		relatedActivityId = attrInRange(
			xmlString,
			'RelatedActivityID',
			corrStart,
			corrGt
		)
		pos = corrGt + 1
	}

	// Execution (multi-attribute self-closing tag)
	let processId = ''
	let threadId = ''
	const [execStart, execGt] = findTag(xmlString, 'Execution', pos)
	if (execStart !== -1) {
		processId = attrInRange(xmlString, 'ProcessID', execStart, execGt)
		threadId = attrInRange(xmlString, 'ThreadID', execStart, execGt)
		pos = execGt + 1
	}
	// Channel
	;[val, pos] = tagTextFrom(xmlString, 'Channel', pos)
	const channel = decodeEntities(val)

	// Computer
	;[val, pos] = tagTextFrom(xmlString, 'Computer', pos)
	const computer = decodeEntities(val)

	// Security (attribute on self-closing tag)
	;[val, pos] = attrValFrom(xmlString, 'Security', 'UserID', pos)
	const securityUserId = val

	// EventData extraction â€” search after </System>
	let eventData = ''
	const afterSystem = sysClose !== -1 ? sysClose + 9 : 0

	const [edContent] = tagTextFrom(xmlString, 'EventData', afterSystem)
	if (edContent) {
		if (edContent.indexOf('<Data') !== -1) {
			eventData = extractDataPairs(edContent)
		}
		if (!eventData && edContent.indexOf('<') !== -1) {
			eventData = extractLeafPairs(edContent)
		}
		if (!eventData) {
			const trimmed = edContent.trim()
			if (trimmed) eventData = decodeEntities(trimmed)
		}
	}

	// UserData fallback
	if (!eventData) {
		const [udContent] = tagTextFrom(xmlString, 'UserData', afterSystem)
		if (udContent) eventData = extractLeafPairs(udContent)
	}

	// RenderingInfo.Message fallback
	if (!eventData) {
		const [riContent] = tagTextFrom(xmlString, 'RenderingInfo', afterSystem)
		if (riContent) {
			const [msg] = tagTextFrom(riContent, 'Message', 0)
			if (msg) eventData = decodeEntities(msg)
		}
	}

	return {
		eventId,
		level,
		provider,
		computer,
		channel,
		task,
		opcode,
		keywords,
		version,
		processId,
		threadId,
		securityUserId,
		activityId,
		relatedActivityId,
		eventData
	}
}
