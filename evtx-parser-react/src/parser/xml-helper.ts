/**
 * Zero-allocation XML field extractor for Windows Event XML.
 *
 * Replaces fast-xml-parser (which builds a full DOM tree) with direct
 * indexOf + substring scanning. The XML structure is predictable since
 * it's generated by our own BinXml serializer.
 */

const EMPTY_RESULT = {
	eventId: '',
	level: 0,
	provider: '',
	computer: '',
	channel: '',
	task: '',
	opcode: '',
	keywords: '',
	version: '',
	processId: '',
	threadId: '',
	securityUserId: '',
	activityId: '',
	relatedActivityId: '',
	eventData: ''
} as const

/** Extract text between <tag ...>text</tag>. Handles attributes on the opening tag. */
function tagText(xml: string, tag: string, from = 0): string {
	const needle = '<' + tag
	const nLen = needle.length
	let open = from
	// Find the tag, ensuring we match the exact name (not a prefix like <Data vs <Database)
	while (true) {
		open = xml.indexOf(needle, open)
		if (open === -1) return ''
		const c = xml.charCodeAt(open + nLen)
		if (c === 62 || c === 32 || c === 47 || c === 9 || c === 10 || c === 13) break // > space / \t \n \r
		open += nLen
	}
	const gt = xml.indexOf('>', open + nLen)
	if (gt === -1 || xml.charCodeAt(gt - 1) === 47) return '' // self-closing />
	const close = xml.indexOf('</' + tag + '>', gt + 1)
	return close === -1 ? '' : xml.substring(gt + 1, close)
}

/** Extract attribute value from <tag attr="value" ...> */
function attrVal(xml: string, tag: string, attr: string, from = 0): string {
	const needle = '<' + tag
	const nLen = needle.length
	let open = from
	while (true) {
		open = xml.indexOf(needle, open)
		if (open === -1) return ''
		const c = xml.charCodeAt(open + nLen)
		if (c === 62 || c === 32 || c === 47 || c === 9 || c === 10 || c === 13) break
		open += nLen
	}
	const gt = xml.indexOf('>', open)
	if (gt === -1) return ''
	const search = attr + '="'
	const aStart = xml.indexOf(search, open + nLen)
	if (aStart === -1 || aStart >= gt) return ''
	const vStart = aStart + search.length
	const vEnd = xml.indexOf('"', vStart)
	return vEnd === -1 || vEnd > gt ? '' : xml.substring(vStart, vEnd)
}

/** Decode basic XML entities. Fast-path returns immediately when no '&' present. */
function decodeEntities(s: string): string {
	if (s.indexOf('&') === -1) return s
	return s
		.replaceAll('&lt;', '<')
		.replaceAll('&gt;', '>')
		.replaceAll('&quot;', '"')
		.replaceAll('&apos;', "'")
		.replaceAll('&amp;', '&')
}

/** Extract <Data Name="x">value</Data> pairs from an EventData section */
function extractDataPairs(section: string): string {
	const pairs: string[] = []
	let pos = 0
	while (true) {
		const ds = section.indexOf('<Data', pos)
		if (ds === -1) break
		const gt = section.indexOf('>', ds + 5)
		if (gt === -1) break
		if (section.charCodeAt(gt - 1) === 47) { pos = gt + 1; continue } // <Data ... />
		const ce = section.indexOf('</Data>', gt + 1)
		if (ce === -1) break
		const value = section.substring(gt + 1, ce)
		if (value) {
			const ni = section.indexOf('Name="', ds + 5)
			if (ni !== -1 && ni < gt) {
				const nvs = ni + 6
				const nve = section.indexOf('"', nvs)
				if (nve !== -1 && nve < gt) {
					pairs.push(section.substring(nvs, nve) + ': ' + decodeEntities(value))
				} else {
					pairs.push(decodeEntities(value))
				}
			} else {
				pairs.push(decodeEntities(value))
			}
		}
		pos = ce + 7 // '</Data>'.length
	}
	return pairs.join('\n')
}

/** Extract leaf text elements (elements with no children) from a section */
function extractLeafPairs(section: string): string {
	const pairs: string[] = []
	let pos = 0
	while (pos < section.length) {
		const lt = section.indexOf('<', pos)
		if (lt === -1) break
		const nc = section.charCodeAt(lt + 1)
		if (nc === 47 || nc === 33 || nc === 63) { // closing tag, comment, PI
			const gt = section.indexOf('>', lt + 2)
			pos = gt === -1 ? section.length : gt + 1
			continue
		}
		// Extract tag name
		let ne = lt + 1
		while (ne < section.length) {
			const c = section.charCodeAt(ne)
			if (c === 32 || c === 62 || c === 47 || c === 9 || c === 10 || c === 13) break
			ne++
		}
		const tag = section.substring(lt + 1, ne)
		const gt = section.indexOf('>', lt)
		if (gt === -1) break
		if (section.charCodeAt(gt - 1) === 47) { pos = gt + 1; continue } // self-closing
		const closeTag = '</' + tag + '>'
		const closePos = section.indexOf(closeTag, gt + 1)
		if (closePos === -1) { pos = gt + 1; continue }
		const content = section.substring(gt + 1, closePos)
		// Only include leaf nodes (no child elements)
		if (content.indexOf('<') === -1) {
			const trimmed = content.trim()
			if (trimmed) pairs.push(tag + ': ' + decodeEntities(trimmed))
		}
		pos = gt + 1
	}
	return pairs.join('\n')
}

export function parseEventXml(xmlString: string): {
	eventId: string
	level: number
	provider: string
	computer: string
	channel: string
	task: string
	opcode: string
	keywords: string
	version: string
	processId: string
	threadId: string
	securityUserId: string
	activityId: string
	relatedActivityId: string
	eventData: string
} {
	if (!xmlString) return { ...EMPTY_RESULT }

	// System fields â€” direct indexOf extraction
	const eventId = decodeEntities(tagText(xmlString, 'EventID'))
	const levelStr = tagText(xmlString, 'Level')
	const level = levelStr ? parseInt(levelStr, 10) || 0 : 0
	const provider = decodeEntities(attrVal(xmlString, 'Provider', 'Name'))
	const computer = decodeEntities(tagText(xmlString, 'Computer'))
	const channel = decodeEntities(tagText(xmlString, 'Channel'))
	const task = tagText(xmlString, 'Task')
	const opcode = tagText(xmlString, 'Opcode')
	const keywords = tagText(xmlString, 'Keywords')
	const version = tagText(xmlString, 'Version')
	const processId = attrVal(xmlString, 'Execution', 'ProcessID')
	const threadId = attrVal(xmlString, 'Execution', 'ThreadID')
	const securityUserId = attrVal(xmlString, 'Security', 'UserID')
	const activityId = attrVal(xmlString, 'Correlation', 'ActivityID')
	const relatedActivityId = attrVal(xmlString, 'Correlation', 'RelatedActivityID')

	// EventData extraction
	let eventData = ''
	const edContent = tagText(xmlString, 'EventData')
	if (edContent) {
		if (edContent.indexOf('<Data') !== -1) {
			eventData = extractDataPairs(edContent)
		}
		if (!eventData && edContent.indexOf('<') !== -1) {
			eventData = extractLeafPairs(edContent)
		}
		if (!eventData) {
			const trimmed = edContent.trim()
			if (trimmed) eventData = decodeEntities(trimmed)
		}
	}

	// UserData fallback
	if (!eventData) {
		const udContent = tagText(xmlString, 'UserData')
		if (udContent) eventData = extractLeafPairs(udContent)
	}

	// RenderingInfo.Message fallback
	if (!eventData) {
		const riContent = tagText(xmlString, 'RenderingInfo')
		if (riContent) {
			const msg = tagText(riContent, 'Message')
			if (msg) eventData = decodeEntities(msg)
		}
	}

	return {
		eventId, level, provider, computer, channel,
		task, opcode, keywords, version,
		processId, threadId, securityUserId,
		activityId, relatedActivityId, eventData
	}
}
