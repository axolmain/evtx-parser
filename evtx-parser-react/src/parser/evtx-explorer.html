<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EVTX Explorer — Interactive Structure Reference</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Outfit:wght@300;400;600;700;800&display=swap" rel="stylesheet" />
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { -webkit-font-smoothing: antialiased; }
        body { background: #0f1420; color: #dce4f0; font-family: 'Outfit', 'Segoe UI', sans-serif; min-height: 100vh; }
        .mono { font-family: 'JetBrains Mono', 'Fira Code', monospace; }

        .header-bar { border-bottom: 1px solid #1e2736; padding: 18px 32px; background: #111827; }
        .header-inner { max-width: 1100px; margin: 0 auto; display: flex; align-items: center; gap: 12px; }
        .header-pip { width: 8px; height: 32px; border-radius: 4px; background: linear-gradient(180deg, #5b9bd5, #e8a44a); }
        .header-title { font-weight: 800; font-size: 18px; letter-spacing: 0.02em; }
        .header-sub { font-size: 12px; color: #6b7a90; margin-left: 4px; }

        .container { max-width: 1100px; margin: 0 auto; padding: 0 32px 64px; }

        /* Breadcrumbs */
        .breadcrumbs { padding: 20px 0 8px; display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
        .bc-sep { color: #3d4a5c; font-size: 13px; }
        .bc-btn { background: none; border: none; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 12px; padding: 4px 8px; border-radius: 4px; transition: background 0.15s; }
        .bc-btn:hover { background: rgba(91,155,213,0.1); }
        .bc-btn.active { color: #dce4f0; font-weight: 700; cursor: default; }
        .bc-btn.active:hover { background: none; }
        .bc-btn.link { color: #5b9bd5; font-weight: 400; }

        /* Title */
        .view-title { padding: 24px 0 32px; }
        .view-title h1 { font-size: 36px; font-weight: 800; letter-spacing: -0.02em; line-height: 1.15; }
        .view-title p { margin-top: 6px; font-family: 'JetBrains Mono', monospace; font-size: 14px; color: #6b7a90; }

        /* Description */
        .desc-box { padding: 20px 24px; background: #151c2c; border: 1px solid #1e2736; border-radius: 8px; margin-bottom: 32px; line-height: 1.7; font-size: 15px; color: #b0b8c8; }

        /* Meta badges */
        .meta-row { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 32px; }
        .meta-badge { padding: 8px 16px; border-radius: 6px; background: #151c2c; border: 1px solid #1e2736; display: flex; gap: 8px; align-items: center; }
        .meta-label { font-size: 12px; color: #6b7a90; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; }
        .meta-value { font-family: 'JetBrains Mono', monospace; font-size: 13px; color: #70c4a0; }

        /* Section headings */
        .section-heading { font-size: 13px; font-weight: 700; color: #6b7a90; letter-spacing: 0.08em; text-transform: uppercase; margin-bottom: 12px; }

        /* Field table */
        .table-wrap { overflow-x: auto; border-radius: 8px; border: 1px solid #2a3040; margin-bottom: 32px; }
        .field-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .field-table th { padding: 10px 14px; text-align: left; font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 700; color: #6b7a90; letter-spacing: 0.08em; text-transform: uppercase; border-bottom: 1px solid #2a3040; background: #1a2030; white-space: nowrap; }
        .field-table td { padding: 8px 14px; border-bottom: 1px solid #1e2736; }
        .field-table tr:hover td { background: rgba(91,155,213,0.06); }
        .field-table .f-offset { font-family: 'JetBrains Mono', monospace; color: #e8a44a; white-space: nowrap; }
        .field-table .f-size { font-family: 'JetBrains Mono', monospace; color: #8892a4; white-space: nowrap; }
        .field-table .f-name { font-weight: 600; color: #dce4f0; white-space: nowrap; }
        .field-table .f-value { font-family: 'JetBrains Mono', monospace; color: #70c4a0; white-space: nowrap; }
        .field-table .f-note { color: #8892a4; min-width: 200px; }

        /* Extra items grid */
        .extra-grid { padding: 16px 24px; background: #151c2c; border: 1px solid #1e2736; border-radius: 8px; display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 6px 24px; margin-bottom: 32px; }
        .extra-item { font-family: 'JetBrains Mono', monospace; font-size: 13px; color: #b0b8c8; padding: 4px 0; }
        .extra-item .code { color: #e8a44a; }
        .extra-item .label { color: #6b7a90; }

        /* Blocks grid */
        .blocks-grid { display: grid; gap: 16px; }
        .blocks-grid.multi { grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }

        /* Block card */
        .block-card { border: 2px solid var(--bc); border-radius: 8px; padding: 20px 24px; cursor: pointer; background: var(--bg); transition: all 0.2s ease; position: relative; }
        .block-card.static { cursor: default; }
        .block-card:not(.static):hover { transform: translateY(-2px); }
        .block-card-head { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; }
        .block-card-title { display: flex; align-items: center; gap: 10px; }
        .block-pip { width: 10px; height: 10px; border-radius: 50%; background: var(--bc); flex-shrink: 0; }
        .block-label { font-family: 'JetBrains Mono', 'Fira Code', monospace; font-weight: 700; font-size: 14px; color: var(--bc); letter-spacing: 0.04em; }
        .block-size { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: #8892a4; white-space: nowrap; }
        .block-desc { font-size: 14px; line-height: 1.6; color: #b0b8c8; }
        .block-explore { margin-top: 12px; font-size: 12px; color: var(--bc); font-weight: 600; letter-spacing: 0.03em; }

        /* Back button */
        .back-btn { margin-top: 40px; background: none; border: 1px solid #2a3040; color: #6b7a90; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 13px; transition: all 0.15s; }
        .back-btn:hover { border-color: #5b9bd5; color: #5b9bd5; }

        /* Visual map button */
        .map-btn {
            position: fixed;
            top: 16px;
            right: 24px;
            z-index: 100;
            background: #1a2030;
            border: 1px solid #2a3040;
            color: #6b7a90;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .map-btn:hover {
            border-color: #5b9bd5;
            color: #5b9bd5;
        }

        .map-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* Visual map overlay */
        .vmap-overlay {
            position: fixed;
            inset: 0;
            z-index: 200;
            background: rgba(10, 14, 22, 0.92);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s;
        }

        .vmap-overlay.open {
            opacity: 1;
            pointer-events: all;
        }

        .vmap-close {
            position: absolute;
            top: 20px;
            right: 28px;
            background: none;
            border: 1px solid #2a3040;
            color: #6b7a90;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .vmap-close:hover {
            border-color: #e8a44a;
            color: #e8a44a;
        }

        .vmap-back {
            position: absolute;
            top: 20px;
            left: 28px;
            background: none;
            border: 1px solid #2a3040;
            color: #6b7a90;
            padding: 6px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            transition: all 0.15s;
            opacity: 0;
            pointer-events: none;
        }

        .vmap-back.visible {
            opacity: 1;
            pointer-events: all;
        }

        .vmap-back:hover {
            border-color: #5b9bd5;
            color: #5b9bd5;
        }

        .vmap-doc {
            width: 320px;
            max-height: 80vh;
            background: #151c2c;
            border: 2px solid #2a3040;
            border-radius: 12px;
            padding: 0;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .vmap-title {
            padding: 16px 20px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #6b7a90;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 700;
            border-bottom: 1px solid #1e2736;
        }

        .vmap-body {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
        }

        .vmap-section {
            border: 2px solid var(--vc);
            border-radius: 8px;
            padding: 16px 18px;
            cursor: pointer;
            background: var(--vbg);
            transition: all 0.2s;
            position: relative;
        }

        .vmap-section:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px var(--vbg);
        }

        .vmap-section.static {
            cursor: default;
            opacity: 0.5;
        }

        .vmap-section.static:hover {
            transform: none;
            box-shadow: none;
        }

        .vmap-section-label {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 12px;
            color: var(--vc);
            letter-spacing: 0.04em;
        }

        .vmap-section-size {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #6b7a90;
            margin-top: 4px;
        }

        .vmap-section-hint {
            font-size: 11px;
            color: #4a5568;
            margin-top: 6px;
        }

        @media (max-width: 640px) {
            .container { padding: 0 16px 48px; }
            .header-bar { padding: 14px 16px; }
            .view-title h1 { font-size: 26px; }
            .blocks-grid.multi { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

<div class="header-bar">
    <div class="header-inner">
        <div class="header-pip"></div>
        <span class="header-title">EVTX Explorer</span>
        <span class="header-sub">Interactive Structure Reference</span>
    </div>
</div>

<button class="map-btn" onclick="toggleMap()">
    <svg viewBox="0 0 24 24">
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 1.5L18.5 9H13V3.5zM6 20V4h5v7h7v9H6z"/>
    </svg>
    Visual Map
</button>

<div class="vmap-overlay" id="vmapOverlay">
    <button class="vmap-close" onclick="toggleMap()">&times;</button>
    <button class="vmap-back" id="vmapBack" onclick="vmapGoBack()">&larr; Back</button>
    <div class="vmap-doc" id="vmapDoc"></div>
</div>

<div class="container" id="app"></div>

<script>
    const VIEWS = {
        root: {
            title: "EVTX File Structure",
            subtitle: "Windows XML Event Log",
            description: "The .evtx format is the native binary log format used by Windows Event Log (introduced in Vista/Server 2008). Each file is a sequential container of 64KB chunks, preceded by a 4KB file header. Events are stored as Binary XML inside variable-length records within each chunk.",
            meta: [
                { label: "Signature", value: '"ElfFile\\0"' },
                { label: "Header", value: "4,096 bytes" },
                { label: "Chunk Size", value: "65,536 bytes each" },
                { label: "Byte Order", value: "Little-endian" },
                { label: "Introduced", value: "Windows Vista / Server 2008" }
            ],
            blocks: [
                { id: "fileHeader", label: "FILE HEADER", size: "4,096 bytes", color: "#e8a44a", desc: "Metadata about the log file: version, chunk count, flags, and integrity checksum.", nav: "fileHeader" },
                { id: "chunks", label: "CHUNKS", size: "65,536 bytes \u00d7 N", color: "#5b9bd5", desc: "Sequence of chunk containers, each holding a header, event records, and unused space.", nav: "chunks" },
                { id: "trailing", label: "TRAILING EMPTY VALUES", size: "Variable", color: "#6b7280", desc: "Zero-byte padding beyond the last chunk to the end of the allocated file size.", nav: null }
            ]
        },
        fileHeader: {
            title: "File Header",
            subtitle: "4,096 bytes at offset 0x0000",
            parent: "root",
            description: "The file header occupies the first 4,096 bytes. It identifies the file as EVTX, tracks which chunks and record IDs are in use, and stores a CRC32 checksum of the first 120 bytes (0x00\u20130x77) for integrity validation. The Dirty flag indicates unclean shutdown; the Full flag indicates the log reached its maximum size.",
            fields: [
                { offset: "0x0000", size: 8, name: "Signature", value: '"ElfFile\\0"', note: "Magic bytes identifying the file format" },
                { offset: "0x0008", size: 8, name: "First Chunk Number", value: "uint64", note: "Oldest chunk index (may wrap if circular)" },
                { offset: "0x0010", size: 8, name: "Last Chunk Number", value: "uint64", note: "Newest chunk index written" },
                { offset: "0x0018", size: 8, name: "Next Record Identifier", value: "uint64", note: "Next event record ID to be assigned" },
                { offset: "0x0020", size: 4, name: "Header Size", value: "128", note: "Size of the header data portion (always 128)" },
                { offset: "0x0024", size: 2, name: "Minor Version", value: "1 or 2", note: "Format minor version" },
                { offset: "0x0026", size: 2, name: "Major Version", value: "3", note: "Format major version (always 3)" },
                { offset: "0x0028", size: 2, name: "Header Block Size", value: "4096", note: "Full header block size including reserved area" },
                { offset: "0x002A", size: 2, name: "Number of Chunks", value: "uint16", note: "Count of chunks in the file (may be inaccurate if corrupt)" },
                { offset: "0x002C", size: 76, name: "Reserved", value: "(empty)", note: "Unknown / reserved bytes" },
                { offset: "0x0078", size: 4, name: "File Flags", value: "Bit field", note: "Bit 0: Dirty (unclean shutdown), Bit 1: Full" },
                { offset: "0x007C", size: 4, name: "Checksum", value: "CRC32", note: "CRC32 of bytes 0x00 through 0x77" },
                { offset: "0x0080", size: 3968, name: "Reserved", value: "(empty)", note: "Padding to fill the 4,096-byte block" }
            ],
            blocks: []
        },
        chunks: {
            title: "Chunks",
            subtitle: "65,536 bytes each",
            parent: "root",
            description: "The file body consists of sequentially laid-out chunks, each exactly 64 KB. Each chunk is a self-contained unit with its own header, a sequence of event records encoded in Binary XML, and trailing unused space. Chunks maintain their own string and template caches for deduplication within the chunk boundary. The chunk header includes CRC32 checksums for both the header and the event record data area.",
            meta: [
                { label: "Chunk Signature", value: '"ElfChnk\\0"' },
                { label: "Fixed Size", value: "65,536 bytes (64 KB)" },
                { label: "Header Size", value: "512 bytes" },
                { label: "String Cache", value: "64 entries" },
                { label: "Template Cache", value: "32 entries" }
            ],
            blocks: [
                { id: "chunkDetail", label: "CHUNK STRUCTURE", size: "65,536 bytes", color: "#5b9bd5", desc: "Click to explore the internal structure of a single chunk: header, event records, and free space.", nav: "chunkDetail" }
            ]
        },
        chunkDetail: {
            title: "Chunk Internal Structure",
            subtitle: "65,536 bytes per chunk",
            parent: "chunks",
            description: "Each chunk contains a 512-byte header followed by variable-length event records and trailing zero-byte free space. The header tracks event numbering, contains string/template offset caches, and stores CRC32 checksums for integrity. The 'Last Event Offset' and 'Free Space Offset' fields (relative to the chunk start) delineate the boundaries between records and unused area.",
            blocks: [
                { id: "chunkHeader", label: "CHUNK HEADER", size: "512 bytes", color: "#70ad47", desc: "Chunk metadata: event numbering, string/template caches, and CRC32 checksums.", nav: "chunkHeader" },
                { id: "eventRecords", label: "EVENT RECORDS", size: "Variable", color: "#ed7d31", desc: "Sequential variable-length event records, each containing a Binary XML document.", nav: "eventRecord" },
                { id: "unused", label: "UNUSED SPACE", size: "Variable", color: "#6b7280", desc: "Zero-filled area from the free space offset to the end of the 64 KB chunk boundary.", nav: null }
            ]
        },
        chunkHeader: {
            title: "Chunk Header",
            subtitle: "512 bytes at chunk offset 0x0000",
            parent: "chunkDetail",
            description: "The chunk header tracks which event records are contained within, provides fast-lookup caches for common strings and templates, and stores CRC32 checksums. The header checksum covers bytes 0x00\u20130x77 (first 120 bytes). The event records checksum covers all event record data in the chunk. The common string offset table allows the Binary XML parser to resolve frequently-used element/attribute names without re-reading each record.",
            fields: [
                { offset: "0x0000", size: 8, name: "Signature", value: '"ElfChnk\\0"', note: "Magic bytes identifying a valid chunk" },
                { offset: "0x0008", size: 8, name: "First Event Log Record #", value: "uint64", note: "Log record number of first event in this chunk" },
                { offset: "0x0010", size: 8, name: "Last Event Log Record #", value: "uint64", note: "Log record number of last event in this chunk" },
                { offset: "0x0018", size: 8, name: "First Event Record ID", value: "uint64", note: "Record identifier of first event" },
                { offset: "0x0020", size: 8, name: "Last Event Record ID", value: "uint64", note: "Record identifier of last event" },
                { offset: "0x0028", size: 4, name: "Header Size", value: "128", note: "Size of the header data (always 128)" },
                { offset: "0x002C", size: 4, name: "Last Event Offset", value: "uint32", note: "Offset (relative to chunk start) of last event record" },
                { offset: "0x0030", size: 4, name: "Free Space Offset", value: "uint32", note: "Offset (relative to chunk start) where free space begins" },
                { offset: "0x0034", size: 4, name: "Event Records CRC32", value: "uint32", note: "CRC32 of all event record data in this chunk" },
                { offset: "0x0038", size: 64, name: "Reserved", value: "(empty)", note: "Unknown / reserved bytes" },
                { offset: "0x0078", size: 4, name: "Unknown (Flags?)", value: "uint32", note: "Possibly flags; purpose not fully documented" },
                { offset: "0x007C", size: 4, name: "Checksum", value: "CRC32", note: "CRC32 of chunk header bytes 0x00\u20130x77" },
                { offset: "0x0080", size: 256, name: "Common String Offsets", value: "64 \u00d7 uint32", note: "Offset table for 64 cached string names within this chunk" },
                { offset: "0x0180", size: 128, name: "Template Pointers", value: "32 \u00d7 uint32", note: "Offset table for 32 cached template definitions within this chunk" }
            ],
            blocks: [
                {
                    id: "templateTable",
                    label: "TEMPLATE POINTER TABLE",
                    size: "128 bytes",
                    color: "#1abc9c",
                    desc: "Deep dive into how the 32-entry chained hash table indexes template definitions within the chunk.",
                    nav: "templateTable"
                }
            ]
        },
        eventRecord: {
            title: "Event Record",
            subtitle: "Variable length, starts with \\x2a\\x2a\\x00\\x00",
            parent: "chunkDetail",
            description: "Each event record is a variable-length structure identified by the magic signature 0x2A2A0000 (ASCII '**'). It contains a unique record ID, a UTC FILETIME timestamp for when the event was written, and the event payload as a Binary XML document. The record size is stored both at the start and end of the record to allow bidirectional traversal. If these two size values don't match, the record may be corrupt.",
            fields: [
                { offset: "0x00", size: 4, name: "Signature", value: "\\x2a\\x2a\\x00\\x00", note: "Magic bytes \"**\" identifying an event record" },
                { offset: "0x04", size: 4, name: "Size", value: "uint32", note: "Total size of this event record in bytes" },
                { offset: "0x08", size: 8, name: "Event Record ID", value: "uint64", note: "Unique sequential identifier for this record" },
                { offset: "0x10", size: 8, name: "Written Time", value: "FILETIME (UTC)", note: "Timestamp when this event was written (100ns intervals since 1601-01-01)" },
                { offset: "0x18", size: "?", name: "Event Data", value: "Binary XML", note: "The event payload encoded as a Binary XML document" },
                { offset: "end\u22124", size: 4, name: "Size (copy)", value: "uint32", note: "Repeat of the size field for reverse traversal / integrity check" }
            ],
            blocks: [
                { id: "binaryXml", label: "BINARY XML DOCUMENT", size: "Variable", color: "#c44e52", desc: "The event payload: a Binary XML document with elements, attributes, substitutions, and template instances.", nav: "binaryXml" }
            ]
        },
        binaryXml: {
            title: "Binary XML Document",
            subtitle: "Event payload encoding",
            parent: "eventRecord",
            description: "Binary XML (BinXml) is Microsoft's compact binary encoding of XML used inside EVTX event records. Rather than storing verbose XML text, it uses single-byte tokens to represent structural elements (open/close tags, attributes, substitutions). String names are stored once in the chunk's common string table and referenced by offset. Templates allow an XML skeleton to be defined once and reused across many events, with per-event values filled in via substitution slots.",
            meta: [
                { label: "Token Size", value: "1 byte each" },
                { label: "String Encoding", value: "UTF-16LE" },
                { label: "Name Resolution", value: "Chunk-relative offsets" },
                { label: "EOF Token", value: "0x00" }
            ],
            blocks: [
                { id: "fragment", label: "FRAGMENT HEADER", size: "4 bytes", color: "#9b59b6", desc: "Optional fragment wrapper with version info (token 0x0F).", nav: "fragment" },
                { id: "element", label: "ELEMENT", size: "Variable", color: "#e74c3c", desc: "XML elements with open/close tags, attributes, and content.", nav: "element" },
                { id: "templateInst", label: "TEMPLATE INSTANCE", size: "Variable", color: "#3498db", desc: "Reusable XML skeleton with substitution value slots.", nav: "templateInstance" },
                { id: "substitution", label: "SUBSTITUTION", size: "4 bytes", color: "#2ecc71", desc: "Placeholder referencing a value in the template instance data.", nav: "substitution" },
                { id: "nameStr", label: "NAME (Common String)", size: "Variable", color: "#f39c12", desc: "UTF-16LE string with hash, stored once per chunk and referenced by offset.", nav: "nameString" }
            ]
        },
        fragment: {
            title: "Fragment Header",
            subtitle: "4 bytes \u2014 Token 0x0F",
            parent: "binaryXml",
            description: "A fragment header is an optional wrapper that may appear at the start of a Binary XML stream. It declares the BinXml version and flags. Multiple fragments may appear in a single document.",
            fields: [
                { offset: "0x00", size: 1, name: "Fragment Header Token", value: "0x0F", note: "Identifies this as a fragment header" },
                { offset: "0x01", size: 1, name: "Major Version", value: "0x01", note: "BinXml major version" },
                { offset: "0x02", size: 1, name: "Minor Version", value: "0x01", note: "BinXml minor version" },
                { offset: "0x03", size: 1, name: "Flags", value: "0x00", note: "Reserved flags (typically zero)" }
            ],
            blocks: []
        },
        element: {
            title: "Element",
            subtitle: "Variable length \u2014 Token 0x01 / 0x41",
            parent: "binaryXml",
            description: "An element represents an XML tag. Token 0x01 opens an element without attributes; 0x41 opens one with an attribute list. The element name is resolved via a chunk-relative offset into the common string table. After the opening tag (closed by token 0x02), the element may contain child elements, text values, or substitutions. The element ends with token 0x04.",
            fields: [
                { offset: "0x00", size: 1, name: "Open Start Element", value: "0x01 or 0x41", note: "0x01 = no attributes, 0x41 = has attributes" },
                { offset: "0x01", size: 2, name: "Dependency ID", value: "uint16", note: "0xFFFF if not set; references another element" },
                { offset: "0x03", size: 4, name: "Data Size", value: "uint32", note: "Size of element data including attributes" },
                { offset: "0x07", size: 4, name: "Element Name Offset", value: "uint32", note: "Chunk-relative offset to the Name structure" },
                { offset: "...", size: "?", name: "Attribute List", value: "variable", note: "Zero or more Attribute structures (if token is 0x41)" },
                { offset: "...", size: 1, name: "Close Start Element", value: "0x02", note: "Marks end of opening tag" },
                { offset: "...", size: "?", name: "Content", value: "variable", note: "Child elements, text, or substitutions" },
                { offset: "...", size: 1, name: "End Element", value: "0x04", note: "Closing tag token" }
            ],
            extra: {
                title: "Attribute Structure",
                fields: [
                    { offset: "0x00", size: 1, name: "Attribute Token", value: "0x06 or 0x46", note: "0x06 = simple attribute, 0x46 = has more data" },
                    { offset: "0x01", size: 4, name: "Attribute Name Offset", value: "uint32", note: "Chunk-relative offset to the Name structure" },
                    { offset: "0x05", size: "?", name: "Attribute Value", value: "variable", note: "Value data or substitution token" }
                ]
            },
            blocks: []
        },
        templateTable: {
            title: "Template Pointer Table",
            subtitle: "128 bytes at chunk offset 0x0180 \u2014 Chained Hash Table",
            parent: "chunkHeader",
            description: "The template pointer table is a 32-entry chained hash table stored in the chunk header. Each entry is a uint32 offset pointing to the first template definition in that hash bucket. Template definitions are scattered throughout the chunk's data area (typically embedded in the first record that uses them). Each definition's first 4 bytes are a 'next' pointer forming a linked list within the same bucket, allowing multiple templates to share a hash slot. To preload all templates before parsing records, you must follow each chain to its end (next == 0). The hash function is: template_offset % 32.",
            fields: [
                {
                    offset: "0x0180",
                    size: 4,
                    name: "Bucket [0]",
                    value: "uint32",
                    note: "Offset to first template definition in bucket 0 (0 = empty)"
                },
                {
                    offset: "0x0184",
                    size: 4,
                    name: "Bucket [1]",
                    value: "uint32",
                    note: "Offset to first template definition in bucket 1 (0 = empty)"
                },
                {
                    offset: "...",
                    size: "...",
                    name: "Bucket [2\u201331]",
                    value: "uint32 each",
                    note: "Remaining 30 buckets, same structure"
                }
            ],
            extra: {
                title: "Template Definition Layout (at each offset)",
                fields: [
                    {
                        offset: "0x00",
                        size: 4,
                        name: "Next Template Offset",
                        value: "uint32",
                        note: "Chunk-relative offset to next definition in this hash bucket (0 = end of chain)"
                    },
                    {
                        offset: "0x04",
                        size: 16,
                        name: "Template GUID",
                        value: "GUID",
                        note: "Unique identifier for this template definition"
                    },
                    {
                        offset: "0x14",
                        size: 4,
                        name: "Data Size",
                        value: "uint32",
                        note: "Size of the template body (BinXml element tree) in bytes"
                    },
                    {
                        offset: "0x18",
                        size: "?",
                        name: "Template Body",
                        value: "BinXml",
                        note: "The XML skeleton with substitution placeholders"
                    }
                ]
            },
            blocks: [
                {
                    id: "templateInst",
                    label: "TEMPLATE INSTANCE (Token 0x0C)",
                    size: "Variable",
                    color: "#3498db",
                    desc: "How records reference and instantiate these cached template definitions.",
                    nav: "templateInstance"
                }
            ]
        },
        templateInstance: {
            title: "Template Instance",
            subtitle: "Variable length \u2014 Token 0x0C",
            parent: "binaryXml",
            description: "Templates are a key optimization in BinXml. A template defines an XML structure skeleton with substitution placeholders. The template definition (identified by a GUID) is stored once in the chunk and referenced by offset via the chunk header's template pointer table. Each event record then provides only the instance data \u2014 the actual values to fill into the substitution slots. This dramatically reduces storage since many events share the same XML structure.",
            fields: [
                { offset: "0x00", size: 1, name: "Template Instance Token", value: "0x0C", note: "Identifies a template instance" },
                { offset: "...", size: "?", name: "Template Definition", value: "variable", note: "Inline or referenced XML skeleton with substitution placeholders" },
                { offset: "...", size: 4, name: "Number of Values", value: "uint32", note: "Count of substitution values in this instance" },
                { offset: "...", size: "?", name: "Value Descriptors", value: "N \u00d7 4 bytes", note: "Array of (size: uint16, type: uint8, padding: uint8) descriptors" },
                { offset: "...", size: "?", name: "Value Data", value: "variable", note: "Concatenated raw value data in descriptor order" }
            ],
            blocks: [
                {
                    id: "templateTable",
                    label: "TEMPLATE POINTER TABLE",
                    size: "128 bytes",
                    color: "#1abc9c",
                    desc: "The chunk header's hash table where template definitions are indexed and chained.",
                    nav: "templateTable"
                }
            ]
        },
        substitution: {
            title: "Substitution",
            subtitle: "4 bytes \u2014 Token 0x0D / 0x0E",
            parent: "binaryXml",
            description: "Substitution tokens are placeholders within a template's XML skeleton. When the Binary XML parser encounters a substitution, it looks up the corresponding value from the template instance's value data array using the substitution ID as an index. Token 0x0D is a normal substitution; 0x0E is an optional substitution (value may be absent). The value type byte specifies how to interpret the raw data (string, integer, FILETIME, GUID, SID, etc.).",
            fields: [
                { offset: "0x00", size: 1, name: "Substitution Token", value: "0x0D or 0x0E", note: "0x0D = required, 0x0E = optional (may be empty)" },
                { offset: "0x01", size: 2, name: "Substitution ID", value: "uint16", note: "Index into the template instance value array" },
                { offset: "0x03", size: 1, name: "Value Type", value: "uint8", note: "Data type code for the substituted value" }
            ],
            extra: {
                title: "Common Value Types",
                items: [
                    "0x00 \u2014 Null", "0x01 \u2014 UnicodeString (UTF-16LE)", "0x04 \u2014 UInt8", "0x06 \u2014 UInt16",
                    "0x08 \u2014 UInt32", "0x0A \u2014 UInt64", "0x0E \u2014 FILETIME", "0x0F \u2014 SYSTEMTIME",
                    "0x10 \u2014 SID", "0x11 \u2014 HexInt32", "0x13 \u2014 BinXml (nested)", "0x14 \u2014 GUID",
                    "0x15 \u2014 SizeT", "0x21 \u2014 HexInt64"
                ]
            },
            blocks: []
        },
        nameString: {
            title: "Name (Common String)",
            subtitle: "Variable length",
            parent: "binaryXml",
            description: "Names are UTF-16LE strings used for XML element and attribute names. They are stored once within the chunk's data area and referenced by chunk-relative offset from the common string offset table in the chunk header (up to 64 cached entries). Each name structure includes a hash value for fast lookup and the character count (not byte count) of the string. The string is NOT null-terminated.",
            fields: [
                { offset: "0x00", size: 4, name: "Unknown", value: "uint32", note: "Purpose not fully documented (possibly next-offset or flags)" },
                { offset: "0x04", size: 2, name: "Name Hash", value: "uint16", note: "Hash of the string for fast cache lookup" },
                { offset: "0x06", size: 2, name: "Character Count", value: "uint16", note: "Number of UTF-16 characters (not bytes)" },
                { offset: "0x08", size: "?", name: "String Data", value: "UTF-16LE", note: "The name string, length = char_count \u00d7 2 bytes, no null terminator" }
            ],
            blocks: []
        }
    };

    let currentView = "root";

    function esc(s) {
        const d = document.createElement("div");
        d.textContent = s;
        return d.innerHTML;
    }

    function hexBg(color, opacity) {
        const r = parseInt(color.slice(1,3),16);
        const g = parseInt(color.slice(3,5),16);
        const b = parseInt(color.slice(5,7),16);
        return `rgba(${r},${g},${b},${opacity})`;
    }

    function getBreadcrumbs(viewId) {
        const trail = [];
        let id = viewId;
        while (id) {
            trail.unshift({ id, title: VIEWS[id].title });
            id = VIEWS[id].parent;
        }
        return trail;
    }

    function renderFieldTable(fields) {
        return `<div class="table-wrap"><table class="field-table">
    <thead><tr><th>Offset</th><th>Size</th><th>Field</th><th>Value</th><th>Notes</th></tr></thead>
    <tbody>${fields.map(f => `<tr>
      <td class="f-offset">${esc(String(f.offset))}</td>
      <td class="f-size">${esc(String(f.size))}</td>
      <td class="f-name">${esc(f.name)}</td>
      <td class="f-value">${esc(f.value)}</td>
      <td class="f-note">${esc(f.note)}</td>
    </tr>`).join("")}</tbody>
  </table></div>`;
    }

    function renderBlock(b) {
        const clickable = !!b.nav;
        return `<div class="block-card${clickable ? "" : " static"}" style="--bc:${b.color};--bg:${hexBg(b.color,0.06)}"
    ${clickable ? `onclick="navigate('${b.nav}')"
    onmouseenter="this.style.background='${hexBg(b.color,0.14)}';this.style.boxShadow='0 8px 24px ${hexBg(b.color,0.2)}'"
    onmouseleave="this.style.background='${hexBg(b.color,0.06)}';this.style.boxShadow='none'"` : ""}>
    <div class="block-card-head">
      <div class="block-card-title">
        <span class="block-pip"></span>
        <span class="block-label">${esc(b.label)}</span>
      </div>
      <span class="block-size">${esc(b.size)}</span>
    </div>
    <p class="block-desc">${esc(b.desc)}</p>
    ${clickable ? `<div class="block-explore">EXPLORE \u2192</div>` : ""}
  </div>`;
    }

    function render() {
        const view = VIEWS[currentView];
        const breadcrumbs = getBreadcrumbs(currentView);
        const app = document.getElementById("app");

        let html = "";

        // Breadcrumbs
        html += `<div class="breadcrumbs">`;
        breadcrumbs.forEach((bc, i) => {
            if (i > 0) html += `<span class="bc-sep">\u203a</span>`;
            const isLast = i === breadcrumbs.length - 1;
            html += `<button class="bc-btn ${isLast ? "active" : "link"}" ${isLast ? "" : `onclick="navigate('${bc.id}')"`}>${esc(bc.title)}</button>`;
        });
        html += `</div>`;

        // Title
        html += `<div class="view-title"><h1>${esc(view.title)}</h1><p>${esc(view.subtitle)}</p></div>`;

        // Description
        html += `<div class="desc-box">${esc(view.description)}</div>`;

        // Meta
        if (view.meta) {
            html += `<div class="meta-row">${view.meta.map(m =>
                `<div class="meta-badge"><span class="meta-label">${esc(m.label)}</span><span class="meta-value">${esc(m.value)}</span></div>`
            ).join("")}</div>`;
        }

        // Fields
        if (view.fields && view.fields.length) {
            html += `<h3 class="section-heading">Field Layout</h3>`;
            html += renderFieldTable(view.fields);
        }

        // Extra
        if (view.extra) {
            html += `<h3 class="section-heading">${esc(view.extra.title)}</h3>`;
            if (view.extra.fields) {
                html += renderFieldTable(view.extra.fields);
            }
            if (view.extra.items) {
                html += `<div class="extra-grid">${view.extra.items.map(item => {
                    const parts = item.split("\u2014");
                    return `<div class="extra-item"><span class="code">${esc(parts[0])}</span>${parts.length > 1 ? `<span class="label">\u2014 ${esc(parts.slice(1).join("\u2014").trim())}</span>` : ""}</div>`;
                }).join("")}</div>`;
            }
        }

        // Blocks
        if (view.blocks && view.blocks.length) {
            html += `<h3 class="section-heading">${view.fields && view.fields.length ? "Related Structures" : "Components"}</h3>`;
            html += `<div class="blocks-grid${view.blocks.length > 1 ? " multi" : ""}">${view.blocks.map(renderBlock).join("")}</div>`;
        }

        // Back
        if (view.parent) {
            html += `<button class="back-btn" onclick="navigate('${view.parent}')">\u2190 Back to ${esc(VIEWS[view.parent].title)}</button>`;
        }

        app.innerHTML = html;
        window.scrollTo({ top: 0, behavior: "smooth" });
    }

    function navigate(viewId) {
        if (VIEWS[viewId]) {
            currentView = viewId;
            render();
        }
    }

    render();

    // ── Visual Map ──
    const VMAP_LEVELS = {
        file: {
            title: "EVTX File",
            sections: [
                {
                    id: "fileHeader",
                    label: "FILE HEADER",
                    size: "4,096 bytes",
                    color: "#e8a44a",
                    flex: 1,
                    nav: null,
                    viewNav: "fileHeader"
                },
                {id: "chunks", label: "CHUNKS", size: "65,536 bytes \u00d7 N", color: "#5b9bd5", flex: 5, nav: "chunk"},
                {
                    id: "trailing",
                    label: "TRAILING SPACE",
                    size: "Variable",
                    color: "#6b7280",
                    flex: 0.5,
                    nav: null,
                    static: true
                }
            ]
        },
        chunk: {
            title: "Chunk (64 KB)",
            sections: [
                {
                    id: "chunkHeader",
                    label: "CHUNK HEADER",
                    size: "512 bytes",
                    color: "#70ad47",
                    flex: 1,
                    nav: null,
                    viewNav: "chunkHeader"
                },
                {id: "records", label: "EVENT RECORDS", size: "Variable", color: "#ed7d31", flex: 5, nav: "record"},
                {
                    id: "unused",
                    label: "UNUSED SPACE",
                    size: "Variable",
                    color: "#6b7280",
                    flex: 1,
                    nav: null,
                    static: true
                }
            ]
        },
        record: {
            title: "Event Record",
            sections: [
                {
                    id: "sig",
                    label: "SIGNATURE",
                    size: "4 bytes \\x2a\\x2a\\x00\\x00",
                    color: "#c44e52",
                    flex: 0.5,
                    nav: null,
                    static: true
                },
                {
                    id: "header",
                    label: "RECORD HEADER",
                    size: "24 bytes",
                    color: "#e8a44a",
                    flex: 1,
                    nav: null,
                    viewNav: "eventRecord"
                },
                {id: "binxml", label: "BINARY XML", size: "Variable", color: "#9b59b6", flex: 5, nav: "binxml"},
                {
                    id: "sizecopy",
                    label: "SIZE COPY",
                    size: "4 bytes",
                    color: "#6b7280",
                    flex: 0.3,
                    nav: null,
                    static: true
                }
            ]
        },
        binxml: {
            title: "Binary XML Document",
            sections: [
                {
                    id: "fragment",
                    label: "FRAGMENT HEADER",
                    size: "4 bytes (0x0F)",
                    color: "#9b59b6",
                    flex: 0.5,
                    nav: null,
                    viewNav: "fragment"
                },
                {
                    id: "template",
                    label: "TEMPLATE INSTANCE",
                    size: "Variable (0x0C)",
                    color: "#3498db",
                    flex: 3,
                    nav: null,
                    viewNav: "templateInstance"
                },
                {
                    id: "elements",
                    label: "ELEMENTS",
                    size: "Variable",
                    color: "#e74c3c",
                    flex: 3,
                    nav: null,
                    viewNav: "element"
                },
                {
                    id: "substitutions",
                    label: "SUBSTITUTIONS",
                    size: "Variable",
                    color: "#2ecc71",
                    flex: 2,
                    nav: null,
                    viewNav: "substitution"
                }
            ]
        }
    };

    let vmapStack = ["file"];

    function toggleMap() {
        const overlay = document.getElementById("vmapOverlay");
        overlay.classList.toggle("open");
        if (overlay.classList.contains("open")) {
            vmapStack = ["file"];
            renderVmap();
        }
    }

    function vmapGoBack() {
        if (vmapStack.length > 1) {
            vmapStack.pop();
            renderVmap();
        }
    }

    function vmapDrillDown(levelId) {
        if (VMAP_LEVELS[levelId]) {
            vmapStack.push(levelId);
            renderVmap();
        }
    }

    function vmapNavigateAndClose(viewId) {
        toggleMap();
        navigate(viewId);
    }

    function renderVmap() {
        const levelId = vmapStack[vmapStack.length - 1];
        const level = VMAP_LEVELS[levelId];
        const doc = document.getElementById("vmapDoc");
        const backBtn = document.getElementById("vmapBack");

        backBtn.classList.toggle("visible", vmapStack.length > 1);

        let html = `<div class="vmap-title">${esc(level.title)}</div><div class="vmap-body">`;

        for (const s of level.sections) {
            const bg = hexBg(s.color, 0.08);
            const isStatic = s.static && !s.viewNav;
            const onclick = s.nav ? `onclick="vmapDrillDown('${s.nav}')"` :
                s.viewNav ? `onclick="vmapNavigateAndClose('${s.viewNav}')"` : "";

            html += `<div class="vmap-section${isStatic ? ' static' : ''}" style="--vc:${s.color};--vbg:${bg};flex:${s.flex}" ${onclick}
                onmouseenter="this.style.background='${hexBg(s.color, 0.18)}'"
                onmouseleave="this.style.background='${bg}'">
                <div class="vmap-section-label">${esc(s.label)}</div>
                <div class="vmap-section-size">${esc(s.size)}</div>
                ${s.nav ? '<div class="vmap-section-hint">Click to drill down \u2192</div>' : ''}
                ${s.viewNav && !s.nav ? '<div class="vmap-section-hint">Click for details \u2192</div>' : ''}
            </div>`;
        }

        html += `</div>`;
        doc.innerHTML = html;
    }
</script>
</body>
</html>