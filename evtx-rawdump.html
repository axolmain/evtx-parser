<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EVTX Raw Dump</title>
<style>
  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  body{font-family:system-ui,-apple-system,sans-serif;background:#0a0a0f;color:#e0e0e0;min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:2rem}
  h1{font-size:1.5rem;margin-bottom:1.5rem;color:#c0c0c0}
  .drop-zone{width:100%;max-width:700px;border:2px dashed #333;border-radius:12px;padding:3rem 2rem;text-align:center;cursor:pointer;transition:border-color .2s,background .2s;background:#111118;margin-bottom:1.5rem}
  .drop-zone:hover,.drop-zone.drag-over{border-color:#5a7;background:#13151f}
  .drop-zone p{color:#888;font-size:.95rem}.drop-zone .icon{font-size:2.5rem;margin-bottom:.5rem}
  input[type="file"]{display:none}
  .status{width:100%;max-width:700px;margin-bottom:1rem;font-size:.85rem;color:#aaa;min-height:1.2em}
  .status.error{color:#e66}.status.success{color:#5a7}
  .warnings{width:100%;max-width:700px;margin-bottom:1rem;display:none}
  .warnings.visible{display:block}
  .warnings summary{cursor:pointer;font-size:.85rem;color:#e9a;padding:.4rem .6rem;background:#1a1510;border:1px solid #3a2a10;border-radius:6px}
  .warnings summary:hover{background:#252010}
  .warnings ul{margin:.5rem 0 0 1.2rem;font-size:.8rem;color:#d90;line-height:1.6;max-height:200px;overflow-y:auto}
  .warnings li{margin-bottom:.2rem}
  .warnings .warn-icon{margin-right:.3rem}
  .controls{width:100%;max-width:700px;display:flex;gap:.75rem;margin-bottom:1rem;flex-wrap:wrap}
  button{padding:.5rem 1.2rem;border:1px solid #333;border-radius:6px;background:#1a1a24;color:#ccc;cursor:pointer;font-size:.85rem;transition:background .15s}
  button:hover:not(:disabled){background:#252530}button:disabled{opacity:.4;cursor:default}
  .stats{font-size:.8rem;color:#666;margin-left:auto;display:flex;align-items:center;gap:1rem}
  .output-wrap{width:100%;max-width:700px;flex:1;display:flex;flex-direction:column;min-height:300px}
  textarea{flex:1;width:100%;min-height:400px;background:#111118;border:1px solid #222;border-radius:8px;color:#c8d0c8;font-family:'Cascadia Code','Fira Code',Consolas,monospace;font-size:.8rem;padding:1rem;resize:vertical;line-height:1.5}
  textarea:focus{outline:none;border-color:#444}
  .progress{width:100%;max-width:700px;height:3px;background:#222;border-radius:2px;margin-bottom:1rem;overflow:hidden}
  .progress-bar{height:100%;width:0%;background:#5a7;transition:width .05s}
</style>
</head>
<body>
<h1>EVTX ‚Üí Raw Byte Dump</h1>
<div class="drop-zone" id="dropZone"><div class="icon">üìÑ</div><p>Drop an .evtx file here or click to browse</p></div>
<input type="file" id="fileInput" accept=".evtx">
<div class="progress"><div class="progress-bar" id="progressBar"></div></div>
<div class="status" id="status"></div>
<details class="warnings" id="warnings">
  <summary id="warningSummary">‚ö† 0 warnings</summary>
  <ul id="warningList"></ul>
</details>
<div class="controls">
  <button id="btnCopy" disabled>Copy XML</button>
  <button id="btnDownload" disabled>Download XML</button>
  <div class="stats" id="stats"></div>
</div>
<div class="controls" id="paginationControls" style="display:none">
  <button id="btnPrev" disabled>&larr; Prev</button>
  <span id="pageInfo" style="font-size:.85rem;color:#888;display:flex;align-items:center"></span>
  <button id="btnNext" disabled>Next &rarr;</button>
  <label style="font-size:.85rem;color:#666;margin-left:auto">Per page:
    <select id="pageSize" style="background:#1a1a24;color:#ccc;border:1px solid #333;border-radius:4px;padding:.2rem .4rem;font-size:.85rem">
      <option value="50">50</option><option value="100" selected>100</option><option value="250">250</option><option value="500">500</option>
    </select>
  </label>
</div>
<div class="output-wrap"><textarea id="output" readonly placeholder="Parsed XML will appear here..."></textarea></div>

<script>
/* ‚ïê‚ïê‚ïê Helpers ‚ïê‚ïê‚ïê */

var HEX = [];
for (var i = 0; i < 256; i++) HEX[i] = i.toString(16).padStart(2, '0').toUpperCase();

function filetimeToIso(dv, offset) {
  var ft = dv.getBigUint64(offset, true);
  if (ft === 0n) return '';
  var ms = Number(ft / 10000n - 11644473600000n);
  var d = new Date(ms);
  if (isNaN(d.getTime())) return '';
  return d.toISOString().slice(0, 19) + '.' + String(Number(ft % 10000000n)).padStart(7, '0') + 'Z';
}

function hexDump(uint8arr) {
  var parts = [];
  for (var i = 0; i < uint8arr.length; i++) parts.push(HEX[uint8arr[i]]);
  return parts.join(' ');
}

function hex32(v) {
  return '0x' + v.toString(16).padStart(8, '0');
}

/* ‚ïê‚ïê‚ïê parseFileHeader ‚ïê‚ïê‚ïê */
function parseFileHeader(buffer, dv) {
  var sig = new TextDecoder().decode(new Uint8Array(buffer, 0, 8));
  if (!sig.startsWith('ElfFile')) throw new Error('Not a valid EVTX file');
  return {
    headerBlockSize: dv.getUint16(40, true)
  };
}

/* ‚ïê‚ïê‚ïê parseChunkHeader ‚ïê‚ïê‚ïê */
function parseChunkHeader(buffer, dv, chunkStart) {
  var commonStrings = new Uint32Array(64);
  for (var i = 0; i < 64; i++) {
    commonStrings[i] = dv.getUint32(chunkStart + 128 + i * 4, true);
  }

  var templatePtrs = new Uint32Array(32);
  for (var i = 0; i < 32; i++) {
    templatePtrs[i] = dv.getUint32(chunkStart + 384 + i * 4, true);
  }

  return {
    chunkStart:              chunkStart,
    firstEventRecordNumber:  Number(dv.getBigUint64(chunkStart + 8, true)),
    lastEventRecordNumber:   Number(dv.getBigUint64(chunkStart + 16, true)),
    firstEventRecordId:      Number(dv.getBigUint64(chunkStart + 24, true)),
    lastEventRecordId:       Number(dv.getBigUint64(chunkStart + 32, true)),
    headerSize:              dv.getUint32(chunkStart + 40, true),
    lastEventRecordOffset:   chunkStart + dv.getUint32(chunkStart + 44, true),
    freeSpaceOffset:         chunkStart + dv.getUint32(chunkStart + 48, true),
    eventRecordsChecksum:    dv.getUint32(chunkStart + 52, true),
    flags:                   dv.getUint32(chunkStart + 120, true),
    headerChecksum:          dv.getUint32(chunkStart + 124, true),
    commonStringOffsets:     commonStrings,
    templatePointers:        templatePtrs,
    recordsStart:            chunkStart + 512,
    chunkEnd:                chunkStart + 65536
  };
}

/* ‚ïê‚ïê‚ïê formatChunkHeaderComment ‚ïê‚ïê‚ïê */
function formatChunkHeaderComment(ci, h) {
  var lines = [];
  lines.push('<!-- ‚ïê‚ïê‚ïê Chunk ' + ci + ' ‚ïê‚ïê‚ïê');
  lines.push('  fileOffset:    ' + hex32(h.chunkStart));
  lines.push('  records:       ' + h.firstEventRecordId + ' .. ' + h.lastEventRecordId);
  lines.push('  recordNumbers: ' + h.firstEventRecordNumber + ' .. ' + h.lastEventRecordNumber);
  lines.push('  headerSize:    ' + h.headerSize);
  lines.push('  lastRecOff:    ' + hex32(h.lastEventRecordOffset));
  lines.push('  freeSpaceOff:  ' + hex32(h.freeSpaceOffset));
  lines.push('  evtRecCRC32:   ' + hex32(h.eventRecordsChecksum));
  lines.push('  hdrCRC32:      ' + hex32(h.headerChecksum));
  lines.push('  flags:         ' + hex32(h.flags));

  var csUsed = [];
  for (var i = 0; i < 64; i++) {
    if (h.commonStringOffsets[i] !== 0) {
      csUsed.push('[' + i + ']=' + hex32(h.commonStringOffsets[i]));
    }
  }
  if (csUsed.length > 0) {
    lines.push('  commonStrings (' + csUsed.length + ' used):');
    for (var i = 0; i < csUsed.length; i += 4) {
      lines.push('    ' + csUsed.slice(i, i + 4).join('  '));
    }
  } else {
    lines.push('  commonStrings: (none)');
  }

  var tpUsed = [];
  for (var i = 0; i < 32; i++) {
    if (h.templatePointers[i] !== 0) {
      tpUsed.push('[' + i + ']=' + hex32(h.templatePointers[i]));
    }
  }
  if (tpUsed.length > 0) {
    lines.push('  templatePtrs (' + tpUsed.length + ' used):');
    for (var i = 0; i < tpUsed.length; i += 4) {
      lines.push('    ' + tpUsed.slice(i, i + 4).join('  '));
    }
  } else {
    lines.push('  templatePtrs: (none)');
  }

  lines.push('-->');
  return lines.join('\n');
}

/* ‚ïê‚ïê‚ïê BinXml Token Types ‚ïê‚ïê‚ïê */
var TOKEN = {
  EOF:                    0x00,
  OPEN_START_ELEMENT:     0x01, // also 0x41 with has-more-data flag
  CLOSE_START_ELEMENT:    0x02,
  CLOSE_EMPTY_ELEMENT:    0x03,
  END_ELEMENT:            0x04,
  VALUE:                  0x05, // also 0x45
  ATTRIBUTE:              0x06, // also 0x46
  CDATA_SECTION:          0x07, // also 0x47
  CHAR_REF:               0x08, // also 0x48
  ENTITY_REF:             0x09, // also 0x49
  PI_TARGET:              0x0A,
  PI_DATA:                0x0B,
  TEMPLATE_INSTANCE:      0x0C,
  NORMAL_SUBSTITUTION:    0x0D,
  OPTIONAL_SUBSTITUTION:  0x0E,
  FRAGMENT_HEADER:        0x0F,
  HAS_MORE_DATA_FLAG:     0x40
};

var TOKEN_NAMES = {};
TOKEN_NAMES[0x00] = 'EOF';
TOKEN_NAMES[0x01] = 'OpenStartElement';
TOKEN_NAMES[0x02] = 'CloseStartElement';
TOKEN_NAMES[0x03] = 'CloseEmptyElement';
TOKEN_NAMES[0x04] = 'EndElement';
TOKEN_NAMES[0x05] = 'Value';
TOKEN_NAMES[0x06] = 'Attribute';
TOKEN_NAMES[0x07] = 'CDATASection';
TOKEN_NAMES[0x08] = 'CharRef';
TOKEN_NAMES[0x09] = 'EntityRef';
TOKEN_NAMES[0x0A] = 'PITarget';
TOKEN_NAMES[0x0B] = 'PIData';
TOKEN_NAMES[0x0C] = 'TemplateInstance';
TOKEN_NAMES[0x0D] = 'NormalSubstitution';
TOKEN_NAMES[0x0E] = 'OptionalSubstitution';
TOKEN_NAMES[0x0F] = 'FragmentHeader';

function tokenName(byte) {
  var base = byte & ~TOKEN.HAS_MORE_DATA_FLAG;
  var name = TOKEN_NAMES[base] || ('Unknown_0x' + HEX[byte]);
  if (byte & TOKEN.HAS_MORE_DATA_FLAG) name += '+MoreData';
  return name;
}

/* ‚ïê‚ïê‚ïê XML Escaping ‚ïê‚ïê‚ïê */
function xmlEscape(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
}

/* ‚ïê‚ïê‚ïê readName ‚ïê‚ïê‚ïê
   Reads a BinXmlName at a chunk-relative offset.
   Name structure:
     0: 4 bytes unknown
     4: 2 bytes hash
     6: 2 bytes number of characters
     8: UTF-16LE string with null terminator

   Returns the name string.
*/
function readName(chunkDv, chunkRelOffset) {
  var numChars = chunkDv.getUint16(chunkRelOffset + 6, true);
  var strBytes = new Uint8Array(chunkDv.buffer, chunkDv.byteOffset + chunkRelOffset + 8, numChars * 2);
  return new TextDecoder('utf-16le').decode(strBytes);
}

/* ‚ïê‚ïê‚ïê readUnicodeTextString ‚ïê‚ïê‚ïê
   Reads a Unicode text string at a position in a DataView.
   Structure:
     0: 2 bytes ‚Äî number of characters
     2: numChars * 2 bytes ‚Äî UTF-16LE string (no null terminator)

   Advances pos.offset past the string.
   Returns the decoded string.
*/
function readUnicodeTextString(dv, bytes, pos) {
  var numChars = dv.getUint16(pos.offset, true);
  pos.offset += 2;
  var strBytes = new Uint8Array(bytes.buffer, bytes.byteOffset + pos.offset, numChars * 2);
  pos.offset += numChars * 2;
  return new TextDecoder('utf-16le').decode(strBytes);
}

/* ‚ïê‚ïê‚ïê Value Type Constants & Rendering ‚ïê‚ïê‚ïê
   Value types used in substitutions and template instance data.
*/
var VALUE_TYPE = {
  NULL:       0x00,
  STRING:     0x01,
  ANSI_STRING:0x02,
  INT8:       0x03,
  UINT8:      0x04,
  INT16:      0x05,
  UINT16:     0x06,
  INT32:      0x07,
  UINT32:     0x08,
  INT64:      0x09,
  UINT64:     0x0A,
  FLOAT:      0x0B,
  DOUBLE:     0x0C,
  BOOL:       0x0D,
  BINARY:     0x0E,
  GUID:       0x0F,
  SIZE:       0x10,
  FILETIME:   0x11,
  SYSTEMTIME: 0x12,
  SID:        0x13,
  HEX32:      0x14,
  HEX64:      0x15,
  BINXML:     0x21
};

/* Render a substitution value to its XML text representation.
   valueBytes: Uint8Array of the raw value data
   valueType:  the type byte from the descriptor
   chunkDv, chunkStart, chunkHeader: context for BinXml-typed subs
*/
function renderSubstitutionValue(valueBytes, valueType, chunkDv, chunkStart, chunkHeader, tplStats) {
  if (valueBytes.length === 0 && valueType !== VALUE_TYPE.NULL) return '';

  // Array flag: bit 0x80 means array of base type
  if (valueType & 0x80) {
    var baseType = valueType & 0x7F;
    // Array of strings: null-terminated UTF-16LE strings concatenated
    if (baseType === VALUE_TYPE.STRING) {
      var s = new TextDecoder('utf-16le').decode(valueBytes);
      // Split on nulls, filter empty, join
      var parts = s.split('\0').filter(function(p) { return p.length > 0; });
      return xmlEscape(parts.join(', '));
    }
    // Fixed-size array types
    var elemSize = 0;
    if (baseType === VALUE_TYPE.INT8 || baseType === VALUE_TYPE.UINT8) elemSize = 1;
    else if (baseType === VALUE_TYPE.INT16 || baseType === VALUE_TYPE.UINT16) elemSize = 2;
    else if (baseType === VALUE_TYPE.INT32 || baseType === VALUE_TYPE.UINT32 || baseType === VALUE_TYPE.FLOAT || baseType === VALUE_TYPE.HEX32) elemSize = 4;
    else if (baseType === VALUE_TYPE.INT64 || baseType === VALUE_TYPE.UINT64 || baseType === VALUE_TYPE.DOUBLE || baseType === VALUE_TYPE.FILETIME || baseType === VALUE_TYPE.HEX64) elemSize = 8;
    else if (baseType === VALUE_TYPE.GUID) elemSize = 16;
    else if (baseType === VALUE_TYPE.SYSTEMTIME) elemSize = 16;
    if (elemSize > 0 && valueBytes.length >= elemSize) {
      var results = [];
      for (var i = 0; i + elemSize <= valueBytes.length; i += elemSize) {
        var elem = new Uint8Array(valueBytes.buffer, valueBytes.byteOffset + i, elemSize);
        results.push(renderSubstitutionValue(elem, baseType, chunkDv, chunkStart, chunkHeader, tplStats));
      }
      return results.join(', ');
    }
    // Fallback: render as hex
    var hex = [];
    for (var i = 0; i < valueBytes.length; i++) hex.push(HEX[valueBytes[i]]);
    return hex.join('');
  }

  var vdv = new DataView(valueBytes.buffer, valueBytes.byteOffset, valueBytes.byteLength);

  switch (valueType) {
    case VALUE_TYPE.NULL:
      return '';
    case VALUE_TYPE.STRING:
      // UTF-16LE, strip trailing null if present
      var s = new TextDecoder('utf-16le').decode(valueBytes);
      if (s.endsWith('\0')) s = s.slice(0, -1);
      return xmlEscape(s);
    case VALUE_TYPE.ANSI_STRING:
      var s = new TextDecoder('ascii').decode(valueBytes);
      if (s.endsWith('\0')) s = s.slice(0, -1);
      return xmlEscape(s);
    case VALUE_TYPE.INT8:
      return String(vdv.getInt8(0));
    case VALUE_TYPE.UINT8:
      return String(vdv.getUint8(0));
    case VALUE_TYPE.INT16:
      return String(vdv.getInt16(0, true));
    case VALUE_TYPE.UINT16:
      return String(vdv.getUint16(0, true));
    case VALUE_TYPE.INT32:
      return String(vdv.getInt32(0, true));
    case VALUE_TYPE.UINT32:
      return String(vdv.getUint32(0, true));
    case VALUE_TYPE.INT64:
      return String(vdv.getBigInt64(0, true));
    case VALUE_TYPE.UINT64:
      return String(vdv.getBigUint64(0, true));
    case VALUE_TYPE.FLOAT:
      return String(vdv.getFloat32(0, true));
    case VALUE_TYPE.DOUBLE:
      return String(vdv.getFloat64(0, true));
    case VALUE_TYPE.BOOL:
      return vdv.getUint32(0, true) ? 'true' : 'false';
    case VALUE_TYPE.BINARY:
      var hex = [];
      for (var i = 0; i < valueBytes.length; i++) hex.push(HEX[valueBytes[i]]);
      return hex.join('');
    case VALUE_TYPE.GUID:
      if (valueBytes.length < 16) return '';
      var d1 = vdv.getUint32(0, true).toString(16).padStart(8, '0');
      var d2 = vdv.getUint16(4, true).toString(16).padStart(4, '0');
      var d3 = vdv.getUint16(6, true).toString(16).padStart(2, '0');
      var d4 = '';
      for (var i = 8; i < 16; i++) d4 += HEX[valueBytes[i]];
      return '{' + d1 + '-' + d2 + '-' + d3 + '-' + d4.slice(0, 4) + '-' + d4.slice(4) + '}';
    case VALUE_TYPE.SIZE:
      if (valueBytes.length === 8) return '0x' + vdv.getBigUint64(0, true).toString(16).padStart(16, '0');
      return '0x' + vdv.getUint32(0, true).toString(16).padStart(8, '0');
    case VALUE_TYPE.FILETIME:
      if (valueBytes.length < 8) return '';
      var ft = vdv.getBigUint64(0, true);
      if (ft === 0n) return '';
      var ms = Number(ft / 10000n - 11644473600000n);
      var d = new Date(ms);
      if (isNaN(d.getTime())) return '';
      return d.toISOString().slice(0, 19) + '.' + String(Number(ft % 10000000n)).padStart(7, '0') + 'Z';
    case VALUE_TYPE.SYSTEMTIME:
      if (valueBytes.length < 16) return '';
      var yr = vdv.getUint16(0, true), mo = vdv.getUint16(2, true), dy = vdv.getUint16(6, true);
      var hr = vdv.getUint16(8, true), mn = vdv.getUint16(10, true), sc = vdv.getUint16(12, true), ms = vdv.getUint16(14, true);
      return yr + '-' + String(mo).padStart(2, '0') + '-' + String(dy).padStart(2, '0')
        + 'T' + String(hr).padStart(2, '0') + ':' + String(mn).padStart(2, '0') + ':' + String(sc).padStart(2, '0')
        + '.' + String(ms).padStart(3, '0') + 'Z';
    case VALUE_TYPE.SID:
      if (valueBytes.length < 8) return '';
      var rev = valueBytes[0], subCount = valueBytes[1];
      var auth = 0;
      for (var i = 2; i < 8; i++) auth = auth * 256 + valueBytes[i];
      var sid = 'S-' + rev + '-' + auth;
      for (var i = 0; i < subCount; i++) {
        if (8 + i * 4 + 4 > valueBytes.length) break;
        sid += '-' + vdv.getUint32(8 + i * 4, true);
      }
      return sid;
    case VALUE_TYPE.HEX32:
      return '0x' + vdv.getUint32(0, true).toString(16).padStart(8, '0');
    case VALUE_TYPE.HEX64:
      return '0x' + vdv.getBigUint64(0, true).toString(16).padStart(16, '0');
    case VALUE_TYPE.BINXML:
      // Recursively parse embedded BinXml
      var embeddedChunkBase = valueBytes.byteOffset - chunkDv.byteOffset;
      return parseBinXmlDocument(valueBytes, chunkDv, chunkStart, chunkHeader, tplStats, embeddedChunkBase);
    default:
      // Unknown type ‚Äî hex dump
      var hex = [];
      for (var i = 0; i < valueBytes.length; i++) hex.push(HEX[valueBytes[i]]);
      return '<!-- unknown value type 0x' + HEX[valueType] + ' -->' + hex.join('');
  }
}

/* ‚ïê‚ïê‚ïê parseContent ‚ïê‚ïê‚ïê
   Parses content tokens inside an element body or attribute data.
   Handles: value text, substitutions, char refs, entity refs, CDATA,
            nested elements, EOF/close tokens (which stop parsing).

   Parameters:
     bytes   - Uint8Array we're reading from (could be chunk-level for template defs)
     dv      - DataView over bytes
     pos     - { offset } cursor
     chunkDv - DataView over the entire chunk
     chunkHeader - chunk header for name lookups
     subs    - substitution values array (null if not inside a template)

   Returns: XML string of the content
*/
function parseContent(bytes, dv, pos, chunkDv, chunkHeader, subs, tplStats, binxmlChunkBase) {
  var xml = '';

  while (pos.offset < bytes.length) {
    var tok = bytes[pos.offset];
    var base = tok & ~TOKEN.HAS_MORE_DATA_FLAG;

    if (base === TOKEN.EOF || base === TOKEN.CLOSE_START_ELEMENT
        || base === TOKEN.CLOSE_EMPTY_ELEMENT || base === TOKEN.END_ELEMENT
        || base === TOKEN.ATTRIBUTE) {
      // Don't consume ‚Äî let the caller handle these
      break;
    }

    if (base === TOKEN.OPEN_START_ELEMENT) {
      xml += parseElement(bytes, dv, pos, chunkDv, chunkHeader, subs, tplStats, binxmlChunkBase);
    } else if (base === TOKEN.VALUE) {
      pos.offset++; // consume token
      var valType = bytes[pos.offset]; pos.offset++; // value type (should be 0x01 StringType)
      var str = readUnicodeTextString(dv, bytes, pos);
      xml += xmlEscape(str);
    } else if (base === TOKEN.NORMAL_SUBSTITUTION) {
      pos.offset++; // consume token
      var subId = dv.getUint16(pos.offset, true); pos.offset += 2;
      var subValType = bytes[pos.offset]; pos.offset++;
      if (subs && subId < subs.length) {
        xml += subs[subId].rendered;
      }
    } else if (base === TOKEN.OPTIONAL_SUBSTITUTION) {
      pos.offset++; // consume token
      var subId = dv.getUint16(pos.offset, true); pos.offset += 2;
      var subValType = bytes[pos.offset]; pos.offset++;
      if (subs && subId < subs.length && subs[subId].type !== VALUE_TYPE.NULL && subs[subId].size > 0) {
        xml += subs[subId].rendered;
      }
    } else if (base === TOKEN.CHAR_REF) {
      pos.offset++; // consume token
      var charVal = dv.getUint16(pos.offset, true); pos.offset += 2;
      xml += '&#' + charVal + ';';
    } else if (base === TOKEN.ENTITY_REF) {
      pos.offset++; // consume token
      var nameOff = dv.getUint32(pos.offset, true); pos.offset += 4;
      var entityName = readName(chunkDv, nameOff);
      xml += '&' + entityName + ';';
    } else if (base === TOKEN.CDATA_SECTION) {
      pos.offset++; // consume token
      var cdataStr = readUnicodeTextString(dv, bytes, pos);
      xml += '<![CDATA[' + cdataStr + ']]>';
    } else if (base === TOKEN.TEMPLATE_INSTANCE) {
      xml += parseTemplateInstance(bytes, dv, pos, chunkDv, chunkHeader, tplStats, binxmlChunkBase);
    } else if (base === TOKEN.FRAGMENT_HEADER) {
      // Embedded fragment (e.g. inside BinXml substitution value)
      xml += parseBinXmlFragment(bytes, dv, pos, chunkDv, chunkHeader, tplStats, binxmlChunkBase);
    } else {
      xml += '<!-- UNEXPECTED content token 0x' + HEX[tok] + ' (' + tokenName(tok) + ') at offset ' + pos.offset + ' -->';
      pos.offset++; // skip to avoid infinite loop
    }
  }

  return xml;
}

/* ‚ïê‚ïê‚ïê parseElement ‚ïê‚ïê‚ïê
   Parses a BinXMLElement (empty or filled).

   Element start:
     0: 1 byte  token (0x01 no attrs, 0x41 has attrs)
     1: 2 bytes dependency id (0xFFFF = not set)
     3: 4 bytes data size
     7: 4 bytes element name offset (chunk-relative)

   If token is 0x41, an attribute list follows after the name offset.

   Then either:
     CloseEmptyElement (0x03) ‚Üí empty element, done
     CloseStartElement (0x02) ‚Üí content ‚Üí EndElement (0x04)
*/
function parseElement(bytes, dv, pos, chunkDv, chunkHeader, subs, tplStats, binxmlChunkBase) {
  var tok = bytes[pos.offset];
  var hasAttrs = !!(tok & TOKEN.HAS_MORE_DATA_FLAG);
  pos.offset++; // consume token

  var depId = dv.getUint16(pos.offset, true); pos.offset += 2;
  var dataSize = dv.getUint32(pos.offset, true); pos.offset += 4;
  var nameOffset = dv.getUint32(pos.offset, true); pos.offset += 4;
  // Skip inline name structure: 4 unknown + 2 hash + 2 numChars + numChars*2 string + 2 null
  var elemNameChars = dv.getUint16(pos.offset + 6, true);
  pos.offset += 10 + elemNameChars * 2;

  var elemName = readName(chunkDv, nameOffset);
  var xml = '<' + elemName;

  // Parse attribute list if present
  if (hasAttrs) {
    var attrListSize = dv.getUint32(pos.offset, true); pos.offset += 4;
    var attrEnd = pos.offset + attrListSize;

    while (pos.offset < attrEnd) {
      var attrTok = bytes[pos.offset];
      var attrBase = attrTok & ~TOKEN.HAS_MORE_DATA_FLAG;
      if (attrBase !== TOKEN.ATTRIBUTE) break;

      pos.offset++; // consume attribute token
      var attrNameOff = dv.getUint32(pos.offset, true); pos.offset += 4;
      // Skip inline attribute name structure
      var attrNameChars = dv.getUint16(pos.offset + 6, true);
      pos.offset += 10 + attrNameChars * 2;
      var attrName = readName(chunkDv, attrNameOff);

      // Attribute data: value text or substitution
      var attrValue = parseContent(bytes, dv, pos, chunkDv, chunkHeader, subs, tplStats, binxmlChunkBase);
      xml += ' ' + attrName + '="' + attrValue + '"';
    }
  }

  // Next token: CloseEmptyElement or CloseStartElement
  if (pos.offset >= bytes.length) {
    return xml + '/>';
  }

  var closeTok = bytes[pos.offset];
  if (closeTok === TOKEN.CLOSE_EMPTY_ELEMENT) {
    pos.offset++; // consume 0x03
    xml += '/>';
  } else if (closeTok === TOKEN.CLOSE_START_ELEMENT) {
    pos.offset++; // consume 0x02
    xml += '>';

    // Parse content until EndElement
    xml += parseContent(bytes, dv, pos, chunkDv, chunkHeader, subs, tplStats, binxmlChunkBase);

    // Consume EndElement token (0x04)
    if (pos.offset < bytes.length && bytes[pos.offset] === TOKEN.END_ELEMENT) {
      pos.offset++;
    }
    xml += '</' + elemName + '>';
  } else {
    xml += '><!-- UNEXPECTED close token 0x' + HEX[closeTok] + ' --></' + elemName + '>';
  }

  return xml;
}

/* ‚ïê‚ïê‚ïê parseTemplateInstance ‚ïê‚ïê‚ïê
   Template instance (0x0C):

   ALWAYS present (10 bytes after token):
     0:  1 byte  token (0x0C)
     1:  1 byte  unknown (version? seen 0x01)
     2:  4 bytes unknown (template identifier?)
     6:  4 bytes template definition data offset (chunk-relative)

   ONLY for inline definitions (additional 23 bytes):
     10: 4 bytes next template definition offset (0 if none)
     14: 16 bytes GUID
     30: 4 bytes data size
     34: ... inline definition data (fragment header + element tree + EOF)

   Then template instance data:
     ...: 4 bytes number of values
     ...: N √ó 4 bytes value descriptors (2 size, 1 type, 1 padding)
     ...: concatenated value data

   Detection: if defDataOffset == chunk-relative position right after defDataOffset,
   the definition is inline. Otherwise it's a back-reference to an earlier definition.
*/
function formatGuid(guidBytes) {
  var dv = new DataView(guidBytes.buffer, guidBytes.byteOffset, 16);
  var d1 = dv.getUint32(0, true).toString(16).padStart(8, '0');
  var d2 = dv.getUint16(4, true).toString(16).padStart(4, '0');
  var d3 = dv.getUint16(6, true).toString(16).padStart(4, '0');
  var d4 = '';
  for (var i = 8; i < 16; i++) d4 += HEX[guidBytes[i]];
  return '{' + d1 + '-' + d2 + '-' + d3 + '-' + d4.slice(0, 4) + '-' + d4.slice(4) + '}';
}

function parseTemplateInstance(bytes, dv, pos, chunkDv, chunkHeader, tplStats, binxmlChunkBase) {
  pos.offset++; // consume 0x0C token

  // Read the always-present 9 bytes
  var unknown1 = bytes[pos.offset]; pos.offset++;                    // +0: version?
  var unknown2 = dv.getUint32(pos.offset, true); pos.offset += 4;   // +1: template id?
  var defDataOffset = dv.getUint32(pos.offset, true); pos.offset += 4; // +5: chunk-relative offset

  // Determine inline vs back-reference:
  // If defDataOffset points to right here (chunk-relative), it's inline.
  var currentChunkRelOffset = binxmlChunkBase + pos.offset;
  var isInline = (defDataOffset === currentChunkRelOffset);

  var guidStr = '';
  var dataSize = 0;

  if (isInline) {
    // Read remaining 23 bytes of inline header
    var nextDefOffset = dv.getUint32(pos.offset, true); pos.offset += 4; // next def offset
    var guidBytesArr = new Uint8Array(bytes.buffer, bytes.byteOffset + pos.offset, 16);
    guidStr = formatGuid(guidBytesArr);
    pos.offset += 16;
    dataSize = dv.getUint32(pos.offset, true); pos.offset += 4;

    // Register this definition keyed by defDataOffset
    if (tplStats) {
      if (!tplStats.defsByOffset[defDataOffset]) {
        tplStats.defsByOffset[defDataOffset] = {
          guid: guidStr,
          defDataOffset: defDataOffset,
          dataSize: dataSize,
          firstSeenRecord: tplStats.currentRecordId
        };
      }
      if (!tplStats.definitions[guidStr]) {
        tplStats.definitions[guidStr] = tplStats.defsByOffset[defDataOffset];
        tplStats.definitionCount++;
      }
    }

    // Skip the inline definition data
    pos.offset += dataSize;
  } else {
    // Back-reference: look up the previously registered definition
    var cachedDef = tplStats ? tplStats.defsByOffset[defDataOffset] : null;
    if (cachedDef) {
      guidStr = cachedDef.guid;
      dataSize = cachedDef.dataSize;
    }
    // No extra bytes to skip ‚Äî instance data follows immediately
  }

  // Track reference
  if (tplStats) {
    tplStats.references.push({
      recordId: tplStats.currentRecordId,
      guid: guidStr,
      defDataOffset: defDataOffset,
      dataSize: dataSize,
      isInline: isInline
    });
    tplStats.referenceCount++;
  }

  // --- Template Instance Data ---
  var numValues = dv.getUint32(pos.offset, true); pos.offset += 4;

  // Read value descriptors
  var descriptors = [];
  for (var i = 0; i < numValues; i++) {
    var valSize = dv.getUint16(pos.offset, true); pos.offset += 2;
    var valType = bytes[pos.offset]; pos.offset++;
    var valPad  = bytes[pos.offset]; pos.offset++;
    descriptors.push({ size: valSize, type: valType });
  }

  // Read value data (concatenated)
  var subs = [];
  for (var i = 0; i < numValues; i++) {
    var desc = descriptors[i];
    var valBytes;
    if (desc.size > 0 && pos.offset + desc.size <= bytes.length) {
      valBytes = new Uint8Array(bytes.buffer, bytes.byteOffset + pos.offset, desc.size);
    } else {
      valBytes = new Uint8Array(0);
    }
    pos.offset += desc.size;
    subs.push({
      type: desc.type,
      size: desc.size,
      bytes: valBytes,
      rendered: renderSubstitutionValue(valBytes, desc.type, chunkDv, chunkHeader ? chunkHeader.chunkStart : 0, chunkHeader, tplStats)
    });
  }

  // Parse the template definition's element tree from the chunk
  var tplFound = true;
  var xml = '';
  try {
    if (dataSize === 0) {
      tplFound = false;
      throw new Error('no template definition found for defOffset=' + hex32(defDataOffset));
    }
    var tplBodyStart = defDataOffset + 24; // skip 24-byte def header (next-ptr, GUID, dataSize)
    if (tplBodyStart + dataSize > chunkDv.byteLength) {
      tplFound = false;
      throw new Error('template def offset ' + hex32(defDataOffset) + ' + size ' + dataSize + ' exceeds chunk');
    }
    
    var tplBytes = new Uint8Array(chunkDv.buffer, chunkDv.byteOffset + tplBodyStart, dataSize);
    var tplDv = new DataView(tplBytes.buffer, tplBytes.byteOffset, tplBytes.byteLength);
    var tplPos = { offset: 0 };

    // Skip fragment header (4 bytes: 0x0F, major, minor, flags)
    if (tplBytes.length >= 4 && tplBytes[0] === TOKEN.FRAGMENT_HEADER) {
      tplPos.offset += 4;
    }

    // Parse the element tree with substitutions
    xml = parseContent(tplBytes, tplDv, tplPos, chunkDv, chunkHeader, subs, tplStats, tplBodyStart);
  } catch (e) {
    xml = '<!-- template parse error: ' + e.message + ' -->';
    tplFound = false;
  }

  if (tplStats && !tplFound) {
    tplStats.missingRefs.push({
      recordId: tplStats.currentRecordId,
      guid: guidStr || '(unknown)',
      defDataOffset: defDataOffset
    });
    tplStats.missingCount++;
  }

  return xml;
}

/* ‚ïê‚ïê‚ïê parseBinXmlDocument ‚ïê‚ïê‚ïê
   The document (BinXmlDocument) consists of:
   * Prologue (BinXmlPI) (zero or one)
   * Fragment (zero or more)
   * Miscellaneous (BinXmlPI) (zero or one)
   * End of file token (0x00)

   Parameters:
     binxml      - Uint8Array of the raw BinXml payload
     chunkDv     - DataView of the entire chunk (for resolving cross-record references)
     chunkStart  - absolute file offset of chunk start (for computing chunk-relative offsets)
     chunkHeader - parsed chunk header (for commonStringOffsets, templatePointers)

   Returns: parsed XML string
*/
function parseBinXmlDocument(binxml, chunkDv, chunkStart, chunkHeader, tplStats, binxmlChunkBase) {
  var pos = { offset: 0 };
  var dv = new DataView(binxml.buffer, binxml.byteOffset, binxml.byteLength);
  var xml = '';

  while (pos.offset < binxml.length) {
    var tok = binxml[pos.offset];
    var base = tok & ~TOKEN.HAS_MORE_DATA_FLAG;

    if (base === TOKEN.EOF) {
      break;
    } else if (base === TOKEN.FRAGMENT_HEADER) {
      xml += parseBinXmlFragment(binxml, dv, pos, chunkDv, chunkStart, chunkHeader, tplStats, binxmlChunkBase);
    } else if (base === TOKEN.PI_TARGET) {
      // Parse PI: target name + PI data
      pos.offset++; // consume 0x0A
      var piNameOff = dv.getUint32(pos.offset, true); pos.offset += 4;
      var piName = readName(chunkDv, piNameOff);
      xml += '<?';
      xml += piName;
      // Expect PI data token (0x0B)
      if (pos.offset < binxml.length && binxml[pos.offset] === TOKEN.PI_DATA) {
        pos.offset++; // consume 0x0B
        var piText = readUnicodeTextString(dv, binxml, pos);
        if (piText) xml += ' ' + piText;
      }
      xml += '?>';
    } else {
      xml += '<!-- UNEXPECTED document token 0x' + HEX[tok] + ' (' + tokenName(tok) + ') at offset ' + pos.offset + ' -->';
      break;
    }
  }

  return xml;
}

/* ‚ïê‚ïê‚ïê parseBinXmlFragment ‚ïê‚ïê‚ïê
   A BinXmlFragment consists of:
   * Fragment header (4 bytes: token 0x0F, major, minor, flags)
   * An element (OpenStartElement) or a template instance (TemplateInstance)

   Advances pos past the fragment. Returns XML string.
*/
function parseBinXmlFragment(binxml, dv, pos, chunkDv, chunkStart, chunkHeader, tplStats, binxmlChunkBase) {
  if (pos.offset + 4 > binxml.length) {
    return '<!-- TRUNCATED fragment header at offset ' + pos.offset + ' -->\n';
  }

  // Consume fragment header (4 bytes)
  pos.offset += 4;

  if (pos.offset >= binxml.length) {
    return '<!-- TRUNCATED after fragment header -->\n';
  }

  var nextTok = binxml[pos.offset];
  var nextBase = nextTok & ~TOKEN.HAS_MORE_DATA_FLAG;

  if (nextBase === TOKEN.TEMPLATE_INSTANCE) {
    return parseTemplateInstance(binxml, dv, pos, chunkDv, chunkHeader, tplStats, binxmlChunkBase);
  } else if (nextBase === TOKEN.OPEN_START_ELEMENT) {
    return parseElement(binxml, dv, pos, chunkDv, chunkHeader, null, tplStats, binxmlChunkBase);
  } else {
    return '<!-- UNEXPECTED post-fragment token 0x' + HEX[nextTok]
      + ' (' + tokenName(nextTok) + ') at offset ' + pos.offset + ' -->\n';
  }
}

/* ‚ïê‚ïê‚ïê parseRecord ‚ïê‚ïê‚ïê */
function parseRecord(buffer, dv, recOff, chunkStart, chunkEnd) {
  if (recOff + 28 > chunkEnd) return null;

  var sig = dv.getUint32(recOff, true);
  if (sig !== 0x00002A2A) return null;

  var size = dv.getUint32(recOff + 4, true);
  if (size < 28 || recOff + size > chunkEnd) return null;

  var sizeCopy = dv.getUint32(recOff + size - 4, true);

  return {
    fileOffset:      recOff,
    chunkOffset:     recOff - chunkStart,
    recordId:        Number(dv.getBigUint64(recOff + 8, true)),
    timestamp:       filetimeToIso(dv, recOff + 16),
    size:            size,
    sizeCopy:        sizeCopy,
    sizeMatch:       size === sizeCopy,
    binxmlLength:    size - 28,
    binxmlBytes:     new Uint8Array(buffer, recOff + 24, size - 28),
    binxmlFirstByte: size > 28 ? dv.getUint8(recOff + 24) : null,
    recordSize:      size
  };
}

/* ‚ïê‚ïê‚ïê formatRecordComment ‚ïê‚ïê‚ïê */
function formatRecordComment(r, ci) {
  var lines = [];
  lines.push('<!-- record=' + r.recordId);
  lines.push('  timestamp:     ' + r.timestamp);
  lines.push('  chunk:         ' + ci);
  lines.push('  fileOffset:    ' + hex32(r.fileOffset));
  lines.push('  chunkOffset:   ' + hex32(r.chunkOffset));
  lines.push('  size:          ' + r.size + ' bytes');
  lines.push('  sizeCopy:      ' + r.sizeCopy + (r.sizeMatch ? ' (match)' : ' (MISMATCH!)'));
  lines.push('  binxml:        length=' + r.binxmlLength + ' bytes');
  if (r.binxmlFirstByte !== null) {
    lines.push('  binxmlStart:   0x' + HEX[r.binxmlFirstByte] + (r.binxmlFirstByte === 0x0F ? ' (FragmentHeader)' : ' (UNEXPECTED!)'));
  }
  lines.push('-->');
  return lines.join('\n');
}

/* ‚ïê‚ïê‚ïê validateChunk ‚ïê‚ïê‚ïê
   Checks a parsed chunk + its records for anomalies.
   Returns an array of warning strings.
*/
function validateChunk(ci, header, records) {
  var warnings = [];

  // Check record count vs header claims
  var expectedCount = header.lastEventRecordId - header.firstEventRecordId + 1;
  if (records.length !== expectedCount) {
    warnings.push('Chunk ' + ci + ': expected ' + expectedCount + ' records (IDs ' + header.firstEventRecordId + '..' + header.lastEventRecordId + '), found ' + records.length);
  }

  // Check record IDs are sequential
  for (var i = 1; i < records.length; i++) {
    if (records[i].recordId !== records[i - 1].recordId + 1) {
      warnings.push('Chunk ' + ci + ', record ' + records[i].recordId + ': non-sequential ID (previous was ' + records[i - 1].recordId + ')');
    }
  }

  // Check each record
  for (var i = 0; i < records.length; i++) {
    var r = records[i];

    // Size mismatch
    if (!r.sizeMatch) {
      warnings.push('Record ' + r.recordId + ': size mismatch ‚Äî header says ' + r.size + ', trailing copy says ' + r.sizeCopy);
    }

    // BinXml doesn't start with fragment header
    if (r.binxmlFirstByte !== null && r.binxmlFirstByte !== 0x0F) {
      warnings.push('Record ' + r.recordId + ': BinXml starts with 0x' + HEX[r.binxmlFirstByte] + ' instead of 0x0F (FragmentHeader)');
    }

    // Empty BinXml
    if (r.binxmlLength === 0) {
      warnings.push('Record ' + r.recordId + ': empty BinXml payload (0 bytes)');
    }

    // Suspiciously small
    if (r.binxmlLength > 0 && r.binxmlLength < 4) {
      warnings.push('Record ' + r.recordId + ': BinXml payload suspiciously small (' + r.binxmlLength + ' bytes)');
    }

    // Empty timestamp
    if (!r.timestamp) {
      warnings.push('Record ' + r.recordId + ': missing or zero timestamp');
    }
  }

  return warnings;
}

/* ‚ïê‚ïê‚ïê parseChunk ‚ïê‚ïê‚ïê */
function parseChunk(buffer, dv, chunkStart) {
  var header = parseChunkHeader(buffer, dv, chunkStart);
  var records = [];
  var recOff = header.recordsStart;

  while (recOff < header.freeSpaceOffset) {
    var rec = parseRecord(buffer, dv, recOff, chunkStart, header.chunkEnd);
    if (!rec) break;
    records.push(rec);
    recOff += rec.recordSize;
  }

  return { header: header, records: records };
}

/* ‚ïê‚ïê‚ïê parseEvtx ‚ïê‚ïê‚ïê */
function parseEvtx(buffer) {
  var dv = new DataView(buffer);
  var fileHeader = parseFileHeader(buffer, dv);

  // Scan for chunks by signature
  var chunkOffsets = [];
  var off = fileHeader.headerBlockSize;
  while (off + 65536 <= buffer.byteLength) {
    var csig = new TextDecoder().decode(new Uint8Array(buffer, off, 8));
    if (csig.startsWith('ElfChnk')) chunkOffsets.push(off);
    off += 65536;
  }

  // Template tracking
  var tplStats = {
    definitions: {},       // guid ‚Üí { guid, defDataOffset, dataSize, firstSeenRecord }
    defsByOffset: {},      // defDataOffset ‚Üí same object as definitions[guid]
    definitionCount: 0,
    references: [],        // [{ recordId, guid, defDataOffset, dataSize, isInline }]
    referenceCount: 0,
    missingRefs: [],       // [{ recordId, guid, defDataOffset }]
    missingCount: 0,
    currentRecordId: 0,    // set per-record before parsing
    parseErrors: []        // [{ recordId, error }]
  };

  // Parse all chunks, validate, build output
  var totalRecords = 0;
  var allWarnings = [];
  var recordOutputs = []; // per-record strings for pagination

  for (var ci = 0; ci < chunkOffsets.length; ci++) {
    tplStats.defsByOffset = {};
    var chunk = parseChunk(buffer, dv, chunkOffsets[ci]);

    // Validate
    var chunkWarnings = validateChunk(ci, chunk.header, chunk.records);
    for (var wi = 0; wi < chunkWarnings.length; wi++) {
      allWarnings.push(chunkWarnings[wi]);
    }

    var chunkHeaderText = formatChunkHeaderComment(ci, chunk.header) + '\n\n';

    // Build a DataView over the entire chunk for cross-record references
    var chunkDv = new DataView(buffer, chunkOffsets[ci], 65536);

    // Emit records
    for (var ri = 0; ri < chunk.records.length; ri++) {
      var r = chunk.records[ri];
      tplStats.currentRecordId = r.recordId;
      var refsBefore = tplStats.referenceCount;

      // BinXml starts at record's chunkOffset + 24 (after record header)
      var binxmlChunkBase = r.chunkOffset + 24;

      // Parse BinXml
      var parsedXml = '';
      try {
        parsedXml = parseBinXmlDocument(r.binxmlBytes, chunkDv, chunkOffsets[ci], chunk.header, tplStats, binxmlChunkBase);
      } catch (e) {
        parsedXml = '<!-- BinXml parse error: ' + e.message + ' -->\n';
        tplStats.parseErrors.push({ recordId: r.recordId, error: e.message });
      }

      // Build template info comment for this record
      var tplComment = '';
      var refsForRecord = tplStats.references.slice(refsBefore);
      if (refsForRecord.length > 0) {
        var ref = refsForRecord[0]; // typically one per record
        var def = tplStats.defsByOffset[ref.defDataOffset];
        tplComment = '<!-- template: guid=' + (ref.guid || '(back-ref)')
          + ' defOffset=' + hex32(ref.defDataOffset)
          + ' dataSize=' + ref.dataSize
          + (ref.isInline ? ' (INLINE definition)' : ' (back-reference' + (def ? ', defined in record ' + def.firstSeenRecord : '') + ')')
          + ' -->\n';
      }

      var recOut = '';
      if (ri === 0) recOut += chunkHeaderText;
      recOut += formatRecordComment(r, ci) + '\n';
      if (tplComment) recOut += tplComment;
      recOut += parsedXml;
      // recOut += '\n<!-- hex: ' + hexDump(r.binxmlBytes) + ' -->\n';
      recordOutputs.push(recOut);
    }

    totalRecords += chunk.records.length;
  }

  // Build summary blurb
  var summary = [];
  summary.push('<?xml version="1.0" encoding="utf-8"?>');
  summary.push('<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  summary.push('   EVTX Parse Summary');
  summary.push('   Chunks:              ' + chunkOffsets.length);
  summary.push('   Total records:       ' + totalRecords);
  summary.push('   Template definitions: ' + tplStats.definitionCount);
  summary.push('   Template references:  ' + tplStats.referenceCount);
  summary.push('   Missing templates:    ' + tplStats.missingCount);
  summary.push('   Parse errors:         ' + tplStats.parseErrors.length);

  if (tplStats.definitionCount > 0) {
    summary.push('');
    summary.push('   Defined templates:');
    var guids = Object.keys(tplStats.definitions);
    for (var i = 0; i < guids.length; i++) {
      var d = tplStats.definitions[guids[i]];
      // Count how many records reference this template
      var refCount = 0;
      for (var j = 0; j < tplStats.references.length; j++) {
        if (tplStats.references[j].guid === guids[i]) refCount++;
      }
      summary.push('     ' + d.guid + '  offset=' + hex32(d.defDataOffset) + '  size=' + d.dataSize + '  refs=' + refCount + '  first=record ' + d.firstSeenRecord);
    }
  }

  if (tplStats.missingCount > 0) {
    summary.push('');
    summary.push('   Missing template references:');
    for (var i = 0; i < tplStats.missingRefs.length; i++) {
      var m = tplStats.missingRefs[i];
      summary.push('     record ' + m.recordId + ': guid=' + m.guid + '  defOffset=' + hex32(m.defDataOffset));
    }
  }

  if (tplStats.parseErrors.length > 0) {
    summary.push('');
    summary.push('   Parse errors:');
    for (var i = 0; i < tplStats.parseErrors.length; i++) {
      var e = tplStats.parseErrors[i];
      summary.push('     record ' + e.recordId + ': ' + e.error);
    }
  }

  summary.push('   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->');
  summary.push('<Events>\n');

  var summaryText = summary.join('\n');
  return {
    summary: summaryText,
    recordOutputs: recordOutputs,
    xml: summaryText + recordOutputs.join('\n\n') + '\n\n</Events>',
    totalRecords: totalRecords,
    numChunks: chunkOffsets.length,
    warnings: allWarnings,
    tplStats: tplStats
  };
}

/* ‚ïê‚ïê‚ïê UI ‚ïê‚ïê‚ïê */
var dropZone = document.getElementById('dropZone');
var fileInput = document.getElementById('fileInput');
var statusEl = document.getElementById('status');
var outputEl = document.getElementById('output');
var btnCopy = document.getElementById('btnCopy');
var btnDownload = document.getElementById('btnDownload');
var progressBar = document.getElementById('progressBar');
var statsEl = document.getElementById('stats');
var warningsEl = document.getElementById('warnings');
var warningSummaryEl = document.getElementById('warningSummary');
var warningListEl = document.getElementById('warningList');
var paginationControls = document.getElementById('paginationControls');
var btnPrev = document.getElementById('btnPrev');
var btnNext = document.getElementById('btnNext');
var pageInfoEl = document.getElementById('pageInfo');
var pageSizeEl = document.getElementById('pageSize');
var xmlResult = '', fileName = '';
var currentRecordOutputs = [], currentSummary = '', currentPage = 0, pageSize = 100;

dropZone.addEventListener('click', function() { fileInput.click(); });
dropZone.addEventListener('dragover', function(e) { e.preventDefault(); dropZone.classList.add('drag-over'); });
dropZone.addEventListener('dragleave', function() { dropZone.classList.remove('drag-over'); });
dropZone.addEventListener('drop', function(e) { e.preventDefault(); dropZone.classList.remove('drag-over'); if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); });
fileInput.addEventListener('change', function(e) { if (e.target.files.length) handleFile(e.target.files[0]); });

function setStatus(msg, type) { statusEl.textContent = msg; statusEl.className = 'status' + (type ? ' ' + type : ''); }

function showWarnings(warnings) {
  warningListEl.innerHTML = '';
  if (warnings.length === 0) {
    warningsEl.classList.remove('visible');
    return;
  }
  warningSummaryEl.textContent = '\u26A0 ' + warnings.length + ' warning' + (warnings.length > 1 ? 's' : '');
  for (var i = 0; i < warnings.length; i++) {
    var li = document.createElement('li');
    li.textContent = warnings[i];
    warningListEl.appendChild(li);
  }
  warningsEl.classList.add('visible');
  warningsEl.open = true;
}

async function handleFile(file) {
  if (!file.name.toLowerCase().endsWith('.evtx')) { setStatus('Please select an .evtx file', 'error'); return; }
  fileName = file.name.replace(/\.evtx$/i, '');
  setStatus('Reading file...');
  outputEl.value = '';
  btnCopy.disabled = true;
  btnDownload.disabled = true;
  progressBar.style.width = '0%';
  statsEl.textContent = '';
  warningsEl.classList.remove('visible');

  try {
    var buffer = await file.arrayBuffer();
    setStatus('Parsing...');
    progressBar.style.width = '50%';
    await new Promise(function(r) { setTimeout(r, 10); });

    var t0 = performance.now();
    var result = parseEvtx(buffer);
    var t1 = performance.now();

    xmlResult = result.xml;
    currentRecordOutputs = result.recordOutputs;
    currentSummary = result.summary;
    currentPage = 0;
    renderPage();
    progressBar.style.width = '100%';
    paginationControls.style.display = currentRecordOutputs.length > pageSize ? 'flex' : 'none';

    var tpl = result.tplStats;
    var statsText = result.totalRecords + ' records ¬∑ ' + result.numChunks + ' chunks ¬∑ '
      + (buffer.byteLength / 1024).toFixed(1) + ' KB ¬∑ ' + (t1 - t0).toFixed(0) + 'ms'
      + ' ¬∑ ' + tpl.definitionCount + ' templates ¬∑ ' + tpl.referenceCount + ' refs';
    if (tpl.missingCount > 0) statsText += ' ¬∑ ' + tpl.missingCount + ' missing!';
    if (tpl.parseErrors.length > 0) statsText += ' ¬∑ ' + tpl.parseErrors.length + ' errors';
    statsEl.textContent = statsText;
    setStatus('Parsed ' + result.totalRecords + ' event records', result.warnings.length > 0 || tpl.missingCount > 0 ? '' : 'success');
    showWarnings(result.warnings);
    btnCopy.disabled = false;
    btnDownload.disabled = false;
  } catch (e) {
    setStatus('Error: ' + e.message, 'error');
    console.error(e);
  }
}

btnCopy.addEventListener('click', async function() {
  await navigator.clipboard.writeText(xmlResult);
  btnCopy.textContent = 'Copied!';
  setTimeout(function() { btnCopy.textContent = 'Copy XML'; }, 1500);
});

btnDownload.addEventListener('click', function() {
  var blob = new Blob([xmlResult], { type: 'application/xml' });
  var a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = fileName + '-rawdump.xml';
  a.click();
  URL.revokeObjectURL(a.href);
});

function renderPage() {
  var total = currentRecordOutputs.length;
  var totalPages = Math.max(1, Math.ceil(total / pageSize));
  if (currentPage >= totalPages) currentPage = totalPages - 1;
  var start = currentPage * pageSize;
  var end = Math.min(start + pageSize, total);
  var pageRecords = currentRecordOutputs.slice(start, end);
  outputEl.value = currentSummary + pageRecords.join('\n\n') + '\n\n</Events>';
  btnPrev.disabled = currentPage === 0;
  btnNext.disabled = currentPage >= totalPages - 1;
  pageInfoEl.textContent = 'Page ' + (currentPage + 1) + ' of ' + totalPages + ' (' + (start + 1) + '\u2013' + end + ' of ' + total + ')';
  outputEl.scrollTop = 0;
}

btnPrev.addEventListener('click', function() { if (currentPage > 0) { currentPage--; renderPage(); } });
btnNext.addEventListener('click', function() { currentPage++; renderPage(); });
pageSizeEl.addEventListener('change', function() {
  pageSize = parseInt(pageSizeEl.value, 10);
  currentPage = 0;
  renderPage();
  paginationControls.style.display = currentRecordOutputs.length > pageSize ? 'flex' : 'none';
});
</script>
</body>
</html>
